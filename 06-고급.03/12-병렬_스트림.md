# 병렬 스트림
자바 병렬 스트림과 관련된 내용을 핵심만 구조적으로 정리.

## 🧠 자바 병렬 스트림 핵심 요약

### ✅ 1. 병렬 스트림의 필요성

| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 단일 스트림의 한계 | 모든 작업이 순차적으로 실행되어 시간이 오래 걸림 (예: 8개 작업 → 8초) |
| 멀티코어 활용 필요 | 현대 CPU는 다중 코어 기반 → 병렬 처리로 성능 향상 가능               |
| 병렬 처리의 장점   | 실행 시간 단축, 자원 활용 극대화, 대용량 데이터 처리에 유리            |
| 병렬 스트림 도입    | `.parallelStream()`으로 간단하게 병렬 처리 구현 가능                   |


### ⚙️ 2. 병렬 처리 방식 비교

| 방식                          | 설명                                                                 |
|-------------------------------|----------------------------------------------------------------------|
| Thread + Runnable             | 직접 스레드 생성 및 실행. 코드 복잡도 높고 예외 처리, 동기화 등 수동 관리 필요 |
| ExecutorService + Callable + Future | 스레드 풀 기반 병렬 처리. 결과 반환 및 예외 처리에 유리하며 관리가 간편함     |
| Fork/Join 프레임워크          | 작업을 재귀적으로 분할하고 병렬 실행. 작업 훔치기(Work Stealing)로 효율적 분산 |
| `.parallelStream()`           | 가장 간단한 병렬 처리 방식. 내부적으로 Fork/Join 프레임워크 사용, 코드 간결함   |


### 🧪 3. 실전 예제 흐름

#### 📍 단일 스트림
```java
IntStream.rangeClosed(1, 8)
    .map(HeavyJob::heavyTask)
    .sum();
```
- 순차 실행 → 약 8초 소요
- 모든 로그에 [main] 스레드만 등장

#### 📍 스레드 직접 사용
```java
static class SumTask implements Runnable {
    int startValue;
    int endValue;
    int result = 0;

    public SumTask(int startValue, int endValue) {
        this.startValue = startValue;
        this.endValue = endValue;
    }

    @Override
    public void run() {
        log("작업 시작");

        int sum = 0;
        for (int i = startValue; i <= endValue; i++) {
            int calculated = HeavyJob.heavyTask(i);
            sum += calculated;
        }
        result = sum;
        log("작업 완료 result=" + result);
    }
}
```

```java
Thread t1 = new Thread(new SumTask(1, 4));
Thread t2 = new Thread(new SumTask(5, 8));
```
- 작업 분할 후 start() → join()
- 약 4초 소요, 코드 복잡도 증가

#### 📍 스레드 풀 사용
```java
ExecutorService es = Executors.newFixedThreadPool(2);
Future<Integer> f1 = es.submit(new SumTask(1, 4));
Future<Integer> f2 = es.submit(new SumTask(5, 8));
```
- Callable + Future.get()로 결과 수집
- 병렬 처리 + 결과 반환 구조 간결

#### 📍 Fork/Join 프레임워크
```java
public class SumTask extends RecursiveTask<Integer> {
    
    private static final int THRESHOLD = 4; // 임계값
    private final List<Integer> list;
    
    public SumTask(List<Integer> list) {
        this.list = list;
    }

    @Override
    protected Integer compute() {
        // 작업 범위가 작으면 직접 합산
        if (list.size() <= THRESHOLD) {

            log("[처리 시작] " + list);
            int sum = list.stream()
            .mapToInt(HeavyJob::heavyTask)
            .sum();

            log("[처리 완료] " + list + " -> sum: " + sum);

            return sum;
        } else {
            // 작업 범위가 크면 반으로 나누어 병렬 처리
            int mid = list.size() / 2;

            List<Integer> leftList = list.subList(0, mid);
            List<Integer> rightList = list.subList(mid, list.size());

            log("[분할] " + list + " -> LEFT" + leftList + ", RIGHT" + rightList);
            SumTask leftTask = new SumTask(leftList);
            SumTask rightTask = new SumTask(rightList);

            // 왼쪽 작업은 다른 스레드에서 처리
            leftTask.fork();

            // 오른쪽 작업은 현재 스레드에서 처리
            int rightResult = rightTask.compute();

            // 왼쪽 작업 결과를 기다림
            int leftResult = leftTask.join();

            // 왼쪽과 오른쪽 작업 결과를 합침
            int joinSum = leftResult + rightResult;

            log("LEFT[" + leftResult + "] + RIGHT[" + rightResult + "] -> sum:" + joinSum);
            return joinSum;
        }
    }
}
```
```java
ForkJoinPool pool = new ForkJoinPool();
int result = pool.invoke(new SumTask(list));
```
- RecursiveTask 상속 + compute() 재귀 분할
- fork() → compute() → join()
- 작업 훔치기(Work Stealing)로 부하 분산

#### 📍 병렬 스트림
```java
IntStream.rangeClosed(1, 8)
    .parallel()
    .map(HeavyJob::heavyTask)
    .sum();
```

- 가장 간단한 병렬 처리 방식
- 내부적으로 Fork/Join 프레임워크 사용
- 병렬성은 자동 조절되며, CPU 코어 수에 따라 성능 향상

### ⚠️ 4. 병렬 스트림 사용 시 주의사항

| 주의 항목               | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 순서 보장 문제           | `.forEach()`는 순서가 뒤섞일 수 있음 → 순서 보장하려면 `.forEachOrdered()` 사용 |
| 공유 자원 접근 주의      | 병렬 환경에서 상태 공유 시 동기화 필요 → `synchronized`, `Concurrent` 컬렉션 사용 |
| 작업량이 적은 경우 역효과 | 병렬 처리 오버헤드로 인해 오히려 성능 저하 발생 가능                   |
| 디버깅 어려움            | 멀티스레드 환경에서는 로그 추적 및 예외 분석이 복잡해짐                  |
| 병렬성 자동 조절         | 병렬 스트림은 내부적으로 CPU 코어 수에 따라 병렬성 수준을 자동 조절함     |

## 🧾 병렬 스트림 정리

| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 목적               | 실행 시간 단축, 멀티코어 자원 활용 극대화                            |
| 핵심 메서드        | `.parallelStream()` 또는 `.stream().parallel()`                      |
| 내부 구조          | Fork/Join 프레임워크 기반으로 병렬 처리 수행                         |
| 장점               | 코드 간결, 자동 병렬성 조절, 대용량 데이터 처리에 유리               |
| 주의사항           | 순서 미보장, 공유 자원 동기화 필요, 작업량 적을 경우 오히려 역효과 가능 |

---

### 🧪 병렬 스트림 실전 샘플 – 전체 코드
#### 📁 1. HeavyJob.java – 무거운 작업 시뮬레이션
```java
public class HeavyJob {
    public static int heavyTask(int i) {
        try {
            Thread.sleep(1000); // 1초 소요되는 작업
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.printf("[%s] calculate %d -> %d\n",
            Thread.currentThread().getName(), i, i * 10);
        return i * 10;
    }
}
```
#### 📁 2. ParallelStreamMain.java – 병렬 스트림 실행
```java
import java.util.stream.IntStream;

public class ParallelStreamMain {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        int sum = IntStream.rangeClosed(1, 8)
            .parallel() // 병렬 스트림 활성화
            .map(HeavyJob::heavyTask)
            .sum();

        long endTime = System.currentTimeMillis();
        System.out.printf("[main] time: %dms, sum: %d\n", (endTime - startTime), sum);
    }
}
```


#### 🖨️ 실행 예시 출력
```java
[ForkJoinPool.commonPool-worker-3] calculate 1 -> 10
[ForkJoinPool.commonPool-worker-5] calculate 2 -> 20
[ForkJoinPool.commonPool-worker-7] calculate 3 -> 30
[ForkJoinPool.commonPool-worker-1] calculate 4 -> 40
[ForkJoinPool.commonPool-worker-2] calculate 5 -> 50
[ForkJoinPool.commonPool-worker-6] calculate 6 -> 60
[ForkJoinPool.commonPool-worker-4] calculate 7 -> 70
[ForkJoinPool.commonPool-worker-0] calculate 8 -> 80
[main] time: 1015ms, sum: 360
```


## ✅ 병렬 스트림 실전 샘플 핵심 포인트

| 항목                         | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `.parallel()`                | 스트림을 병렬로 처리하도록 설정. 내부적으로 Fork/Join 프레임워크 사용 |
| `HeavyJob` 클래스            | 1초 소요되는 무거운 작업을 시뮬레이션. 병렬 처리 효과를 직관적으로 확인 가능 |
| 병렬 실행 확인               | 여러 스레드에서 작업이 동시에 실행됨. 실행 시간 단축 가능             |
| `Thread.currentThread().getName()` | 현재 작업을 수행 중인 스레드 이름 확인. 병렬 실행 여부를 로그로 확인 가능 |

- 이 샘플은 병렬 스트림의 성능 향상 효과를 직관적으로 보여주는 예제입니다.

---


