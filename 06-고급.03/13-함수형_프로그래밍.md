# 함수형 프로그래밍
핵심 내용을 구조적으로 정리.  
자바의 함수형 프로그래밍 개념부터 실전 예제까지 모두 포함.

## 🧠 함수형 프로그래밍 핵심 요약
### ✅ 1. 프로그래밍 패러다임 분류

| 패러다임           | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 명령형 (Imperative) | 어떻게(How) 수행할지 명령과 제어 흐름 중심. 상태 변화와 절차 강조         |
| 절차지향           | 명령형의 하위 개념. 함수나 프로시저 단위로 순차적 실행. 예: C, Pascal     |
| 객체지향           | 데이터와 함수를 객체로 묶어 추상화. 캡슐화, 상속, 다형성 등 특징. 예: Java |
| 선언형 (Declarative)| 무엇(What)을 할지 선언. 구현 방식은 추상화. 예: SQL, HTML, 함수형 프로그래밍 |
| 함수형             | 선언형의 하위 개념. 순수 함수, 불변성, 부수 효과 최소화. 예: Haskell, Java(람다) |

### 🧩 2. 함수형 프로그래밍의 주요 특징

| 개념                   | 설명                                                                 |
|------------------------|----------------------------------------------------------------------|
| 순수 함수               | 동일 입력 → 항상 동일 출력. 외부 상태에 의존하거나 변경하지 않음         |
| 부수 효과 최소화        | 외부 상태 변경(출력, 변수 수정 등)을 지양. 테스트와 병렬 처리에 유리       |
| 불변성 지향             | 데이터 변경 대신 새 객체 생성. 상태 변화 없음                           |
| 일급 시민 함수          | 함수를 변수에 저장, 인자로 전달, 반환 가능. 고차 함수 구현 가능           |
| 선언형 접근             | 어떻게가 아닌 무엇을 할지 기술. 스트림 API와 잘 어울림                   |
| 함수 합성               | 작은 함수들을 조합해 복잡한 로직 구성. 재사용성과 가독성 향상             |
| 지연 평가 (Lazy Evaluation) | 필요한 시점까지 계산을 미룸. 불필요한 계산 비용 절감                     |

### 🧪 3. 자바에서의 함수형 프로그래밍 실전 예제
#### 📍 순수 함수 예제
```java
Function<Integer, Integer> func = x -> x * 2;
System.out.println(func.apply(10)); // 항상 20 반환
```

#### 📍 부수 효과 예제
```java
int count = 0;
Function<Integer, Integer> func = x -> {
    count++; // 외부 상태 변경 → 부수 효과 발생
    return x * 2;
};
```

#### 📍 불변 객체 예제
```java
public final class ImmutablePerson {
    private final String name;
    private final int age;

    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(name, newAge); // 새 객체 반환
    }
}
```

#### 📍 일급 시민 함수 예제
```java
Function<Integer, Integer> func = x -> x * 2;
applyFunction(10, func); // 함수 인자로 전달
Function<Integer, Integer> getFunc() { return x -> x * 2; } // 함수 반환
```

#### 📍 선언형 접근 예제
```java
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .toList();
```

### ⚠️ 4. 함수형 프로그래밍의 장점

| 구분     | 설명                                                                 |
|----------|----------------------------------------------------------------------|
| 장점     | 외부 상태 변경이 없으므로 디버깅과 테스트가 용이함                    |
| 장점     | 불변성 기반으로 병렬 처리와 동시성에 유리함                           |
| 장점     | 선언형 접근으로 코드 가독성과 유지보수성 향상                         |

### ⚠️ 5. 함수형 프로그래밍의 단점

| 구분     | 설명                                                                 |
|----------|----------------------------------------------------------------------|
| 단점     | 명령형 사고에 익숙한 개발자에게는 진입 장벽이 있음                    |
| 단점     | 불변 데이터 처리로 인해 메모리 사용량 증가 가능성                     |
| 단점     | 내부 동작이 추상화되어 디버깅이나 최적화가 어려울 수 있음             |


## 🧾 정리
- 자바는 객체지향 언어지만, 자바 8부터 람다식, 함수형 인터페이스, 스트림 API 등을 통해 함수형 스타일을 지원
- 함수형 프로그래밍은 순수 함수, 불변성, 부수 효과 최소화를 통해 안정적이고 예측 가능한 코드를 작성하게 도와줌
- 자바는 멀티 패러다임 언어로, 상황에 따라 절차지향, 객체지향, 함수형 스타일을 혼합해 사용하는 것이 실무적으로 가장 유연함


--- 

# 실무 예제

자바에서 함수형 프로그래밍의 핵심 개념인 순수 함수, 불변성, 스트림 + 람다를 활용한 실전 예제를 아래에 구성.

## 🧪 실전 예제: 주문 목록에서 VIP 고객의 총 주문 금액 계산
### 🎯 시나리오

고객 주문 리스트에서 VIP 고객만 필터링하고, 각 주문 금액을 합산하여 총액을 계산하는 로직을 함수형 스타일로 구현합니다.

### 📁 1. Order.java – 주문 정보 클래스
```java
public class Order {
    private final String customerName;
    private final boolean isVip;
    private final int amount;

    public Order(String customerName, boolean isVip, int amount) {
        this.customerName = customerName;
        this.isVip = isVip;
        this.amount = amount;
    }

    public boolean isVip() {
        return isVip;
    }

    public int getAmount() {
        return amount;
    }

    @Override
    public String toString() {
        return customerName + " (VIP: " + isVip + ") → " + amount;
    }
}
```


### 📁 2. OrderProcessor.java – 함수형 처리 로직
```java
import java.util.List;

public class OrderProcessor {
    public static int calculateVipTotal(List<Order> orders) {
        return orders.stream()
            .filter(Order::isVip)               // VIP 고객 필터링
            .mapToInt(Order::getAmount)         // 주문 금액 추출
            .sum();                             // 총합 계산
    }
}
```


### 📁 3. Main.java – 실행 클래스
```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Order> orders = List.of(
            new Order("Kim", true, 100),
            new Order("Lee", false, 200),
            new Order("Park", true, 150),
            new Order("Choi", false, 300)
        );

        int vipTotal = OrderProcessor.calculateVipTotal(orders);
        System.out.println("VIP 고객 총 주문 금액: " + vipTotal);
    }
}
```


### 🖨️ 실행 결과
```java
VIP 고객 총 주문 금액: 250
```


## ✅ 함수형 포인트 요약

| 항목                         | 설명                                                                 |
|------------------------------|----------------------------------------------------------------------|
| `calculateVipTotal()`        | 순수 함수로 외부 상태 변경 없이 입력 → 출력만 수행                   |
| `Order` 클래스의 `final` 필드 | 불변성(Immutable)을 유지하여 상태 변화 없이 안전한 데이터 처리 가능     |
| `stream().filter().mapToInt().sum()` | 선언형 접근 방식으로 로직을 간결하게 표현. 가독성과 유지보수성 향상         |


---
