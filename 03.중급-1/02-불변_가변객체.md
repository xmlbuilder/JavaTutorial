# 🧠 자바 기본형 vs 참조형 공유 정리
## 1️⃣ 기본형(Primitive Type)
- int, double, boolean 등
- 값 자체를 복사해서 대입 → 절대로 공유되지 않음
### 예제
```java
int a = 10;
int b = a; // 값 복사
b = 20;
```

### 결과
```java
a = 10
b = 20
```

- a와 b는 각각 독립된 값을 가짐
- b를 변경해도 a는 영향 없음

## 2️⃣ 참조형(Reference Type)
- 클래스, 배열, 객체 등
- 참조값(주소)을 복사해서 대입 → 객체 공유 가능
### 예제
```java
Address a = new Address("서울");
Address b = a;
b.setValue("부산");
```

### 결과
```java
a = Address{value='부산'}
b = Address{value='부산'}
```

- a와 b는 같은 객체(x001)를 참조
- b를 통해 값을 변경하면 a도 함께 변경됨

## 3️⃣ 사이드 이펙트(Side Effect)
- 참조형 변수 공유로 인해 의도치 않은 변경이 발생하는 현상
- 디버깅이 어려워지고 코드 안정성 저하
### 예제
```java
change(b, "부산");

private static void change(Address address, String changeAddress) {
    address.setValue(changeAddress);
}
```

- b를 변경했지만 a도 함께 변경됨 → 사이드 이펙트 발생

## 4️⃣ 해결 방법
### ✅ 서로 다른 객체를 참조
```java
Address a = new Address("서울");
Address b = new Address("서울");
```

- a와 b는 각각 다른 인스턴스를 참조
- b.setValue("부산") → a는 영향 없음

## 5️⃣ 객체 공유를 막을 수 없는 이유
- 자바는 값 대입 시 항상 복사를 수행
- 기본형: 값 복사 → 공유 없음
- 참조형: 참조값 복사 → 공유 발생
```java
Address b = a; // 참조값 복사 → 공유 발생
```

- 자바 문법상 b = a는 정상적인 코드
- 개발자가 실수로 객체를 공유해도 컴파일 오류 없음

## 6️⃣ 실무 팁 — 참조형 공유와 사이드 이펙트 방지
| 상황                         | 권장 방식                                      |
|------------------------------|------------------------------------------------|
| 값 변경이 독립적이어야 할 때 | 서로 다른 객체를 생성해서 참조                 |
| 객체 공유가 필요한 경우      | 변경 범위를 명확히 관리하거나 불변 객체 사용     |
| 사이드 이펙트 방지           | 객체 복사 또는 불변 객체 패턴 적용             |
| 메서드 인자로 객체 전달 시   | 참조값이 전달된다는 점을 인지하고 주의할 것     |
| 협업 시 안정성 확보          | 객체 변경이 외부에 영향을 주지 않도록 설계      |

----

# 🧠 자바 불변 객체(Immutable Object) 도입 정리
## 1️⃣ 문제의 본질: 공유된 객체의 값 변경
- 참조형 변수는 객체를 공유할 수 있음
- 공유 자체는 문제가 아님
- 문제의 직접 원인은 공유된 객체의 값을 변경하는 것
### 예시
```java
Address a = new Address("서울");
Address b = a;
b.setValue("부산"); // a도 함께 변경됨 → 사이드 이펙트 발생
```


## 2️⃣ 불변 객체란?
- 상태가 절대 변하지 않는 객체
- 필드를 final로 선언하고, 변경 메서드(setValue) 제거
- 생성자에서만 값을 설정 가능
### 예시: 불변 클래스 정의
```java
public class ImmutableAddress {
    private final String value;

    public ImmutableAddress(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "Address{" + "value='" + value + '\'' + '}';
    }
}
```


## 3️⃣ 불변 객체의 효과
- 값을 변경할 수 없으므로 사이드 이펙트가 원천 차단
- 값을 변경하려면 새로운 객체를 생성해야 함
### 예시
```java
ImmutableAddress a = new ImmutableAddress("서울");
ImmutableAddress b = a;
b = new ImmutableAddress("부산"); // a는 그대로 유지됨
```


## 4️⃣ 가변 vs 불변 객체 비교

| 구분           | Address (가변 객체)                          | ImmutableAddress (불변 객체)                      |
|----------------|----------------------------------------------|--------------------------------------------------|
| 값 변경 가능 여부 | 가능 (`setValue()`로 내부 상태 변경)           | 불가능 (값 변경 메서드 없음)                      |
| 사이드 이펙트    | 발생 가능 (공유된 객체의 상태가 변경됨)         | 없음 (값 변경 시 새 객체 생성)                    |
| 공유 참조 시 위험| 높음 (다른 변수도 함께 변경될 수 있음)         | 낮음 (기존 객체는 변경되지 않음)                  |
| 변경 방식       | 내부 필드 직접 수정                           | `withXxx()` 메서드로 새 객체 반환                 |
| 예시 결과       | `a`, `b` 모두 부산으로 변경됨                  | `a`는 서울 유지, `b`만 부산으로 변경됨            |


## 5️⃣ 실전 예제: 회원 주소 변경
### ❌ 가변 객체 사용 — 사이드 이펙트 발생
```java
Address address = new Address("서울");
MemberV1 memberA = new MemberV1("회원A", address);
MemberV1 memberB = new MemberV1("회원B", address);

memberB.getAddress().setValue("부산"); // memberA도 함께 변경됨
```

### 실행 결과
```
memberA = Address{value='부산'}
memberB = Address{value='부산'}
```


### ✅ 불변 객체 사용 — 사이드 이펙트 없음
```java
ImmutableAddress address = new ImmutableAddress("서울");
MemberV2 memberA = new MemberV2("회원A", address);
MemberV2 memberB = new MemberV2("회원B", address);

memberB.setAddress(new ImmutableAddress("부산")); // memberA는 그대로 유지
```

### 실행 결과
```
memberA = Address{value='서울'}
memberB = Address{value='부산'}
```

## 6️⃣ 핵심 정리 — 불변 객체의 원리와 효과
| 항목                     | 설명                                                                 |
|--------------------------|----------------------------------------------------------------------|
| 객체 공유                | 자바에서 참조형 객체는 여러 변수에서 공유 가능                        |
| 사이드 이펙트 발생 조건  | 공유된 객체의 내부 상태가 변경될 때 발생                              |
| 불변 객체의 역할         | 내부 상태 변경을 금지하여 사이드 이펙트를 원천 차단                    |
| 값 변경 방식             | 기존 객체는 유지하고, 변경된 값을 가진 새 객체를 생성하여 반환         |
| withXxx() 패턴           | 불변 객체에서 값을 변경할 때 사용하는 관례적 메서드 이름               |
| 실무 적용                | 멀티쓰레드, 캐시, 설정값, 도메인 값 타입 등에서 안정성 확보에 유리       |


---

# 🧠 불변 객체에서 값 변경하기 — 핵심 정리
## 1️⃣ 불변 객체의 원칙
- 객체의 상태는 절대 변경되지 않아야 함
- 값을 변경하는 대신 새로운 객체를 생성해서 반환

## 2️⃣ 가변 객체 vs 불변 객체 비교
| 항목               | MutableObj (가변 객체)                          | ImmutableObj (불변 객체)                          |
|--------------------|--------------------------------------------------|--------------------------------------------------|
| 값 변경 가능 여부   | 가능 (`add()` 메서드로 내부 상태 직접 변경)       | 불가능 (`add()`는 새 객체를 반환)                 |
| 사이드 이펙트 발생  | 가능 (공유된 객체의 상태가 변경됨)               | 없음 (기존 객체는 변경되지 않음)                  |
| 변경 방식           | 내부 필드 직접 수정                              | 계산 결과로 새 객체 생성 후 반환                  |
| 반환값 처리         | 반환값 없이도 상태 변경 가능                     | 반환값을 반드시 받아야 변경 결과를 활용 가능       |
| 예시 결과           | 기존 값은 사라지고 새 값으로 덮어씀 (`10 → 30`)  | 기존 값 유지, 새 객체에 변경값 저장 (`10 → 30`)   |



## 3️⃣ 불변 객체에서 값 변경 — add() 예시
```java
public ImmutableObj add(int addValue) {
    int result = value + addValue;
    return new ImmutableObj(result);
}
```
- 기존 객체는 그대로 유지
- 계산 결과를 담은 새 객체 반환
### 결과
```
obj1 = 10
obj2 = 30
```


## 4️⃣ 반환값을 꼭 받아야 하는 이유
```java
obj1.add(20); // 반환값을 저장하지 않으면 아무 일도 안 일어남
System.out.println(obj1.getValue()); // 여전히 10
```

- 불변 객체는 내부 상태를 변경하지 않기 때문에
반환된 새 객체를 반드시 변수에 저장해야 함

## 5️⃣ 불변 객체의 변경 메서드 — withXxx() 패턴
```java
public ImmutableMyDate withYear(int newYear) {
    return new ImmutableMyDate(newYear, month, day);
}
```

- withYear()는 기존 객체를 기반으로
새로운 연도 값을 가진 객체를 생성해서 반환

### 예시 결과
```
date1 = 2024-1-1
date2 = 2024-1-1
2025 -> date1
date1 = 2025-1-1
date2 = 2024-1-1
```

- date1만 변경되고 date2는 그대로 유지됨 → 사이드 이펙트 없음

## 6️⃣ 불변 객체를 사용하는 이유
| 목적                   | 설명                                                                 |
|------------------------|----------------------------------------------------------------------|
| 사이드 이펙트 방지      | 공유된 객체의 상태 변경을 원천 차단하여 예측 가능한 동작 보장          |
| 멀티쓰레드 안정성       | 여러 스레드에서 동시에 접근해도 상태 변경이 없으므로 안전함             |
| 캐시 안정성            | 값이 변하지 않으므로 캐싱된 객체를 그대로 재사용 가능                  |
| 도메인 모델의 값 타입   | 엔티티의 속성으로 사용할 때 불변 객체는 설계와 추적이 쉬움              |
| 유지보수와 디버깅 용이  | 상태 변경이 없으므로 코드 흐름 추적이 간단하고 버그 발생 가능성 감소     |


## 7️⃣ 실무 팁
- 자바의 String, Integer, LocalDate 등은 모두 불변 객체
- 모든 클래스를 불변으로 만들 필요는 없음
- 변경되면 안 되는 값을 다룰 때 불변 객체를 적극 활용
- 불변 객체는 설계 철학이자 안정성 확보 전략

---

