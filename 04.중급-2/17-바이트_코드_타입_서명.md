# 바이트 코드 타입 서명
이 표는 **Java의 바이트코드에서 사용되는 타입 서명(Type Signature)**을 설명하는 것입니다.  
즉, 자바 컴파일러가 .class 파일을 생성할 때 내부적으로 사용하는 JVM 타입 표현 방식.  
이 형식은 Java Virtual Machine Specification에 정의되어 있으며,  
리플렉션이나 ASM 같은 바이트코드 조작 라이브러리에서 자주 등장합니다.

## 🔍 각 타입 서명의 의미

| 타입 서명       | Java 타입         | 예시 또는 설명                                 |
|----------------|-------------------|------------------------------------------------|
| `Z`            | `boolean`         |                                                |
| `B`            | `byte`            |                                                |
| `C`            | `char`            |                                                |
| `S`            | `short`           |                                                |
| `I`            | `int`             |                                                |
| `J`            | `long`            |                                                |
| `F`            | `float`           |                                                |
| `D`            | `double`          |                                                |
| `L...;`        | 참조형 클래스     | `Ljava/lang/String;` → `String` 클래스         |
| `[type`        | 배열              | `[I` → `int[]`, `[Ljava/lang/String;` → `String[]` |
| `(args)ret`    | 메서드 시그니처   | `(I)Z` → `boolean func(int)`                   |



## 📌 예시 해석
- Ljava/lang/String; → String 클래스
- [I → int[]
- [[D → double[][]
- (Ljava/lang/String;I)V → void method(String, int)
- (I)Z → boolean method(int)
- ()V → void method() (인자 없음)

## 🛠️ 어디에 쓰이나요?
- JVM 내부에서 메서드나 필드 타입을 표현할 때
- 리플렉션 API에서 Method.getGenericSignature() 같은 메서드
- 바이트코드 조작 라이브러리 (예: ASM, BCEL)
- 디컴파일러나 클래스 분석 도구


## 🔍 JVM 타입 서명 해석

| Java 메서드 시그니처               | JVM 타입 서명                                      | 해석 요약         |
|----------------------------------|---------------------------------------------------|-------------------|
| `int sum(int a, int b)`          | `(II)I`                                           | int, int → int    |
| `String echo(String msg)`        | `(Ljava/lang/String;)Ljava/lang/String;`         | String → String   |
| `void store(Fruit fruit)`        | `(LFruit;)V`                                      | Fruit → void      |
| `boolean isEmpty(List<String>)`  | `(Ljava/util/List;)Z`                             | List → boolean    |
| `double[][] matrix()`            | `()[[D`                                           | → double[][]      |


## 📌 구성 규칙 요약
- 기본 타입
- I → int
- Z → boolean
- D → double
- V → void
- 참조 타입
- L패키지/클래스명; → 예: Ljava/lang/String;
- 배열 타입
- [I → int[], [[D → double[][]
- 메서드 타입
- (인자들)반환타입 → 괄호 안은 인자 타입, 뒤는 반환 타입

## 🧠 해석 방식
아래처럼 직접 해석함:
- (Ljava/lang/String;I)Z → boolean method(String, int)
- ([Ljava/lang/String;)V → void method(String[] args)
- (FJ)D → double method(float, long)
- 리버스 툴(예: 디컴파일러)이 .class 파일에서 변수 이름 없이도 소스 코드를 복원할 수 있는 이유는 다음과 같은 원리 때문

## 🔍 왜 변수 이름이 없을까?
Java 컴파일러는 .java 소스 파일을 .class 바이트코드로 변환할 때:
- **지역 변수 이름(local variable names)** 은 기본적으로 제거됩니다.
- 대신 **로컬 변수 테이블(LocalVariableTable)** 이라는 디버그 정보에 이름이 포함될 수 있습니다.
- 이 정보는 javac -g 옵션으로 컴파일할 때만 포함됩니다.

## 🧠 그럼 디컴파일러는 어떻게 복원할까?
디컴파일러는 다음 정보를 기반으로 추론합니다:

### 1. 타입 정보
- JVM은 각 변수의 타입을 알고 있습니다 (int, String, List, 등).
- 예: (Ljava/lang/String;)I → String을 받아 int를 반환

### 2. 명령 흐름
- 바이트코드 명령어 (iload_0, invokevirtual, return)를 분석해 어떤 연산이 수행되는지 파악합니다.

### 3. 스택 위치와 인덱스
- 지역 변수는 인덱스로 저장됨 (local[0], local[1] 등)
- 디컴파일러는 이를 기반으로 arg0, var1 같은 이름을 자동 생성하거나 추론된 이름을 붙입니다.

### 4. 패턴 인식
- for, if, while 같은 구조는 바이트코드 패턴으로 인식 가능
- 디컴파일러는 이를 고수준 구조로 복원

## 📦 예시
```java
public int sum(int a, int b) {
    return a + b;
}
```

### 컴파일된 바이트코드에는 a, b라는 이름이 없을 수 있지만:
- sum 메서드의 시그니처 (II)I → 두 개의 int 인자
- iload_0, iload_1, iadd, ireturn → 두 값을 더해서 반환

### 디컴파일러는 이를 보고:
```java
public int sum(int arg0, int arg1) {
    return arg0 + arg1;
}
```
- 혹은 이름을 추론해서 원래처럼 복원할 수도 있음.

## 🛠️ 디컴파일러 예시 도구
- CFR: 이름 추론이 뛰어남
- JD-GUI: GUI 기반 디컴파일
- Procyon, Fernflower: IntelliJ에 내장된 디컴파일러

---


