# XML 요소 찾기

## 🧭 XML 처리 단계별 설명
### ✅ 1. XML 파서 준비
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document document = builder.parse(...);
```
- XML 파일 또는 문자열을 파싱해 Document 객체 생성
- DocumentBuilderFactory는 파서 설정을 담당

### ✅ 2. 루트 요소 접근
```java
Element root = document.getDocumentElement();
System.out.println(root.getNodeName());
```
- XML의 최상위 요소를 가져옴 (<novelists> 등)

### ✅ 3. 특정 태그 탐색
```java
NodeList novelists = document.getElementsByTagName("novelist");
```
- 원하는 태그 이름으로 요소 목록을 가져옴
- 반복문으로 각 노드에 접근 가능

### ✅ 4. 자식 요소 접근
```java
Element name = getChildElem((Element)node, "name");
```
- 커스텀 함수 getChildElem()을 통해 자식 요소 탐색
- getFirstChild()부터 getNextSibling()까지 순회

### ✅ 5. 텍스트 추출
```java
String nameText = name.getTextContent();
```
- 요소의 텍스트 값을 가져옴
- getContent() 함수는 CDATA, TEXT 노드만 추출

### ✅ 6. 날짜 파싱 및 객체 생성
```java
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
Date birth = formatter.parse(birthElement.getTextContent());
```
- 문자열을 Date 객체로 변환
- NoveItem 객체로 구조화

### ✅ 7. 문자열 기반 XML 처리
```java
Document doc = builder.parse(new InputSource(new StringReader(xmlString)));
```
- 파일 없이 문자열로 XML을 처리할 수 있음
- 테스트나 네트워크 응답 처리에 유용

## 🧠 핵심 함수 요약
| 함수명             | 역할 및 설명                                                  |
|--------------------|---------------------------------------------------------------|
| `getChildElem()`   | 부모 요소에서 특정 이름의 자식 요소를 찾아 반환               |
| `getContent()`     | 요소 내부의 텍스트/CDATA 노드만 추출하여 문자열로 반환         |
| `getElementsByTagName()` | 특정 태그 이름으로 요소 목록을 가져옴 (`NodeList`)         |
| `getDocumentElement()` | XML의 루트 요소를 반환 (`Element`)                          |
| `parse()`          | XML 파일 또는 문자열을 파싱하여 `Document` 객체 생성          |
| `getTextContent()` | 요소의 텍스트 값을 반환                                        |
| `getNodeType()`    | 노드 타입 확인 (ELEMENT_NODE, TEXT_NODE 등)                   |

## ✨ 전체 흐름 요약
- 1. XML 파서 생성 → Document 객체 획득
- 2. 루트 요소 접근 → 원하는 태그 탐색
- 3. 자식 요소 접근 → 텍스트 추출
- 4. 필요한 데이터 구조화 → 객체 생성
- 5. 결과 출력 또는 활용

---

# XML 수정

## 🧭 XML 처리 흐름 단계별 요약
### ✅ 1. XML 파싱 (DOM 기반)
- DocumentBuilderFactory → 파서 생성
- DocumentBuilder → XML 문서 파싱
- Document → DOM 트리 구조로 표현
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse(new InputSource(new StringReader(xmlString)));
```

### ✅ 2. DOM 탐색 및 데이터 추출
- 루트 요소 접근: getDocumentElement()
- 특정 태그 탐색: getElementsByTagName("novelist")
- 자식 요소 접근: getChildNodes(), getFirstChild(), getNextSibling()
- 텍스트 추출: getTextContent(), getNodeValue()

### ✅ 3. XPath를 이용한 고급 탐색
- XPathFactory → XPath 객체 생성
- XPathExpression → 경로 컴파일
- evaluate() → 노드 집합 반환
```java
XPath xpath = XPathFactory.newInstance().newXPath();
XPathExpression expr = xpath.compile("//novelists");
NodeList nodes = (NodeList) expr.evaluate(doc, XPathConstants.NODESET);
```

### ✅ 4. DOM 수정
- 노드 삭제: parentNode.removeChild(targetNode)
- 노드 추가: appendChild(), createElement()

### ✅ 5. XML 직렬화 및 역직렬화 (Java Beans)
- XMLEncoder → 객체를 XML로 저장
- XMLDecoder → XML에서 객체 복원
```java
XMLEncoder encoder = new XMLEncoder(new FileOutputStream("file.xml"));
encoder.writeObject(obj);
encoder.close();

XMLDecoder decoder = new XMLDecoder(new FileInputStream("file.xml"));
Object obj = decoder.readObject();
decoder.close();
```

### ✅ 6. 파일 잠금 처리 (NIO)
- FileChannel.lock() → 파일 쓰기 중 동시 접근 방지
- ByteBuffer → 바이트 단위 쓰기

## 🧠 핵심 클래스 및 함수 요약
| 클래스/인터페이스        | 역할 및 설명                                                  |
|--------------------------|---------------------------------------------------------------|
| `DocumentBuilderFactory` | XML 파서 팩토리 생성                                          |
| `DocumentBuilder`        | XML 문서 파싱                                                 |
| `Document`               | DOM 트리 구조 표현                                            |
| `Element`, `Node`        | XML 요소 및 노드 표현                                         |
| `NodeList`               | 다수 노드 집합                                                |
| `XPath`, `XPathExpression` | XPath 경로 탐색 및 평가                                      |
| `XMLEncoder`             | Java 객체를 XML로 직렬화                                      |
| `XMLDecoder`             | XML에서 Java 객체로 역직렬화                                  |
| `Transformer`            | DOM → XML 문자열로 변환                                       |
| `FileChannel`, `FileLock`| 파일 쓰기 시 동시 접근 제어                                   |

## ✨ 주요 함수 요약
| 함수명              | 설명                                                             |
|---------------------|------------------------------------------------------------------|
| `parse()`           | XML 문자열 또는 파일을 DOM 구조로 파싱                           |
| `getDocumentElement()` | 루트 요소 반환                                                  |
| `getElementsByTagName()` | 특정 태그 이름으로 요소 집합 반환                             |
| `getTextContent()`  | 요소의 텍스트 내용 추출                                          |
| `evaluate()`        | XPath 경로 평가 후 결과 반환                                     |
| `removeChild()`     | 특정 노드를 DOM 트리에서 제거                                    |
| `writeObject()`     | 객체를 XML로 직렬화                                              |
| `readObject()`      | XML에서 객체 복원                                                |
| `lock()` / `release()` | 파일 잠금 및 해제                                               |

## 📦 활용 예시
- 설정 파일 처리: UserSettings 객체를 XML로 저장/복원
- 데이터 구조 직렬화: College와 Student 객체를 XML로 저장
- XPath 기반 필터링: 특정 조건의 노드만 추출
- 파일 동기화 제어: FileLock으로 다중 쓰기 방지

## 샘플 코드

### 1. XML 파일 입력
```java
package com.thj;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;

public class XMLParserTest {
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        
        Document document = documentBuilder.parse("/Users/jeongjunghwan/Development/Temp/novelists.xml");
        
        Element root = document.getDocumentElement();
        System.out.println(root.getNodeName());
        
        NodeList childrent = root.getChildNodes();
        for(int i=0; i<childrent.getLength(); i++){
            Node node = childrent.item(i);
            NodeList child1 = node.getChildNodes();
            for(int j=0; j<child1.getLength(); j++)
            {
                Node childNode = child1.item(j);
                if(childNode.getNodeType() == Node.ELEMENT_NODE){
                    Element element = (Element) childNode;
                    if(!childNode.getNodeName().isEmpty()){
                        System.out.println(childNode.getNodeName() + " : " + element.getTextContent().trim());
                    }
                }
            }
        }
    }
}
```

### 2. XML Query
```java
package com.thj;
import org.w3c.dom.*;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
public class XMLParserTest {
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        Document document = documentBuilder.parse("/Users/jeongjunghwan/Development/Temp/novelists.xml");
        Element root = document.getDocumentElement();
        NodeList nodelists = document.getElementsByTagName("novelist");
        System.out.println(nodelists.getLength());
        for(int i=0; i<nodelists.getLength(); i++){
            Node node = nodelists.item(i);
            Element name = getChildElem((Element) node, "name");
            Element birth = getChildElem((Element)node, "birth");
            System.out.println(name.getTextContent());
            System.out.println(birth.getTextContent());
        }
    }
    public static String getContent(Element elem){
        NodeList nodeList = elem.getChildNodes();
        StringBuffer content = new StringBuffer();
        for(int i=0; i<nodeList.getLength(); i++){
            Node node = nodeList.item(i);
            switch (node.getNodeType()){
                case Node.ELEMENT_NODE:
                    continue;
                case Node.CDATA_SECTION_NODE:
                case Node.TEXT_NODE:
                    content.append(node.getNodeValue());
                    break;
            }
        }
        return content.toString().trim();
    }
    public static Element getChildElem(Element parent, String name){
        for(Node child = parent.getFirstChild(); child != null; child = child.getNextSibling()){
            if(child instanceof Element && name.equals(child.getNodeName())){
                return (Element) child;
            }
        }
        return null;
    }
}

var xdoc = XDocument.Load("/Users/jeongjunghwan/Development/Temp/novelists.xml");
var xnovelists = xdoc.Root.Elements();
foreach (var xnovelist in xnovelists)
{
    var xname = xnovelist.Element("name");
    var works = xnovelist.Element("masterpieces")
        .Elements("title").Select(x => x.Value.Trim());
    
    Console.WriteLine($"{xname.Value} {String.Join(", ", works)}");
}

```

### 3. 사용자 지정 클래스 형태로 추출
```java
package com.thj;
import org.w3c.dom.*;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class XMLParserTest {

    class NoveItem {
        private String name;
        private Date birth;
        private Date death;
        private List<String> masterpieces = new ArrayList<>();
        public NoveItem(String name, Date birth, Date death, List<String> masterpieces) {
            this.name = name;
            this.birth = birth;
            this.death = death;
            this.masterpieces = masterpieces;
        }
        public String getName() {
            return name;
        }
        public Date getBirth() {
            return birth;
        }
        public Date getDeath() {
            return death;
        }
        public List<String> getMasterpieces() {
            return masterpieces;
        }
    }
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, ParseException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        Document document = documentBuilder.parse("/Users/jeongjunghwan/Development/Temp/novelists.xml");
        Element root = document.getDocumentElement();
        NodeList novelists = document.getElementsByTagName("novelist");
        List<NoveItem> noveItemList = new ArrayList<>();
        for(int i=0; i<novelists.getLength(); i++){
            Node node = novelists.item(i);
            Element name = getChildElem((Element)node, "name");
            Element birth = getChildElem((Element)node, "birth");
            Element death = getChildElem((Element)node, "death");
            Element masterpieces = getChildElem((Element) node, "masterpieces");
            NodeList titles = masterpieces.getElementsByTagName("title");
            List<String> listMasterPieces = new ArrayList<>();
            for(int j=0; j<titles.getLength(); j++){
                Element title = (Element) titles.item(j);
                listMasterPieces.add(title.getTextContent());
            }
            String strName = name.getTextContent();
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
            Date dateBirth = formatter.parse(birth.getTextContent());
            Date dateDeath = formatter.parse(death.getTextContent());
            XMLParserTest.NoveItem noveItem = new XMLParserTest().new NoveItem(strName, dateBirth, dateDeath, listMasterPieces);
            noveItemList.add(noveItem);
        }
        for(var nove :  noveItemList){
            System.out.println(nove.getName());
            System.out.println(nove.getBirth());
            System.out.println(nove.getDeath());
            System.out.println(nove.getMasterpieces().size());
            System.out.println(String.join(", ", nove.getMasterpieces()));
        }
    }
    public static String getContent(Element elem){
        NodeList nodeList = elem.getChildNodes();
        StringBuffer content = new StringBuffer();
        for(int i=0; i<nodeList.getLength(); i++){
            Node node = nodeList.item(i);
            switch (node.getNodeType()){
                case Node.ELEMENT_NODE:
                    continue;
                case Node.CDATA_SECTION_NODE:
                case Node.TEXT_NODE:
                    content.append(node.getNodeValue());
                    break;
            }
        }
        return content.toString().trim();
    }
    public static Element getChildElem(Element parent, String name){
        for(Node child = parent.getFirstChild(); child != null; child = child.getNextSibling()){
            if(child instanceof Element && name.equals(child.getNodeName())){
                return (Element) child;
            }
        }
        return null;
    }
}
```

### 4. XML - 문자열 XML 파싱
```java
package com.thj;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
public class XMLParserTest {
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, ParseException {

        StringBuffer sb = new StringBuffer();
        sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        sb.append("<novelists>");
        sb.append("<novelist>");
        sb.append("<name eng=\"Sidney Sheldon\">시드니 셸던</name>");
        sb.append("<birth>1917-02-11</birth>");
        sb.append("<death>2007-01-30</death>");
        sb.append("<masterpieces>");
        sb.append("<title>게임의 여왕</title>");
        sb.append("<title>천사의 분노</title>");
        sb.append("</masterpieces>");
        sb.append("</novelist>");
        sb.append("</novelists>");
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        Document document = documentBuilder.parse(new InputSource(new StringReader(sb.toString())));

        Element root = document.getDocumentElement();
        NodeList novelists = document.getElementsByTagName("novelist");
        System.out.println(novelists.getLength());
    }
}

```

### 5. XML - xpath 사용
```java
package com.thj;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.sql.rowset.spi.XmlWriter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class XMLParserTest {
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, TransformerException, XPathExpressionException {
        StringBuffer sb = new StringBuffer();
        sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        sb.append("<novelists>");
        sb.append("<novelist>");
        sb.append("<name eng=\"Sidney Sheldon\">시드니 셸던</name>");
        sb.append("<birth>1917-02-11</birth>");
        sb.append("<death>2007-01-30</death>");
        sb.append("<masterpieces>");
        sb.append("<title>게임의 여왕</title>");
        sb.append("<title>천사의 분노</title>");
        sb.append("</masterpieces>");
        sb.append("</novelist>");
        sb.append("</novelists>");
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        Document document = documentBuilder.parse(new InputSource(new StringReader(sb.toString())));

        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xpath = xPathFactory.newXPath();
        XPathExpression expr = xpath.compile("//novelists");
        Object result = expr.evaluate(document, XPathConstants.NODESET);
        NodeList nodes = (NodeList) result;
        System.out.println(nodes.getLength());
        for(int i=0; i<nodes.getLength(); i++){
            Node node = nodes.item(i);
            System.out.println(node.getTextContent());
        }
    }
}
```

### 6. XML - XML 요소 제거
```java
package com.thj;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.sql.rowset.spi.XmlWriter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class XMLParserTest {
    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, TransformerException, XPathExpressionException {
        StringBuffer sb = new StringBuffer();
        sb.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        sb.append("<novelists>");
        sb.append("<novelist>");
        sb.append("<name eng=\"Sidney Sheldon\">시드니 셸던</name>");
        sb.append("<birth>1917-02-11</birth>");
        sb.append("<death>2007-01-30</death>");
        sb.append("<masterpieces>");
        sb.append("<title>게임의 여왕</title>");
        sb.append("<title>천사의 분노</title>");
        sb.append("</masterpieces>");
        sb.append("</novelist>");
        sb.append("</novelists>");
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = factory.newDocumentBuilder();
        Document document = documentBuilder.parse(new InputSource(new StringReader(sb.toString())));
        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xpath = xPathFactory.newXPath();
        XPathExpression expr = xpath.compile("//novelists");
        Object result = expr.evaluate(document, XPathConstants.NODESET);
        NodeList nodes = (NodeList) result;
        System.out.println(nodes.getLength());
        if(nodes.getLength() == 0) return;
        Node removeNode = nodes.item(0);
        Node parentNode = removeNode.getParentNode();
        if(parentNode != null){
            parentNode.removeChild(removeNode);
        }
        result = expr.evaluate(document, XPathConstants.NODESET);
        NodeList newNodes = (NodeList) result;
        System.out.println(newNodes.getLength());

        for(int i=0; i<nodes.getLength(); i++){
            Node node = nodes.item(i);
            System.out.println(node.getTextContent());
        }
    }
}

```

### 7. 객체를 XML로
```java
package com.thj;

public class UserSettings
{
    public UserSettings(){}
    private Integer fieldOne;
    private String fieldTwo;
    private boolean fieldThree;
    public Integer getFieldOne() {
        return fieldOne;
    }
    public void setFieldOne(Integer fieldOne) {
        this.fieldOne = fieldOne;
    }
    public String getFieldTwo() {
        return fieldTwo;
    }
    public void setFieldTwo(String fieldTwo) {
        this.fieldTwo = fieldTwo;
    }
    public boolean isFieldThree() {
        return fieldThree;
    }
    public void setFieldThree(boolean fieldThree) {
        this.fieldThree = fieldThree;
    }
    @Override
    public String toString() {
        return "UserSettings{" +
                "fieldOne=" + fieldOne +
                ", fieldTwo='" + fieldTwo + '\'' +
                ", fieldThree=" + fieldThree +
                '}';
    }
}
package com.thj;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.xpath.*;
import java.beans.ExceptionListener;
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.*;

public class XMLParserTest {
    private static void serializeToXML(UserSettings userSettings, String filePath){
        try(FileOutputStream fos = new FileOutputStream(filePath)) {
            XMLEncoder encoder = new XMLEncoder(fos);
            encoder.setExceptionListener(new ExceptionListener() {
                @Override
                public void exceptionThrown(Exception e) {
                    System.out.println("Exception! : " + e.toString());
                }
            });
            encoder.writeObject(userSettings);
            encoder.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private static UserSettings deserizableFromXML(String strFilePath){
        UserSettings userSettings = null;
        try(FileInputStream fis = new FileInputStream(strFilePath)){
            XMLDecoder decoder = new XMLDecoder(fis);
            userSettings = (UserSettings)decoder.readObject();
            decoder.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return userSettings;
    }

    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, TransformerException, XPathExpressionException {
        UserSettings userSettings = new UserSettings();
        userSettings.setFieldOne(1);
        userSettings.setFieldTwo("sample");
        serializeToXML(userSettings, "/Users/jeongjunghwan/Downloads/Sample123.xml");
        UserSettings readObj = deserizableFromXML("/Users/jeongjunghwan/Downloads/Sample123.xml");
        System.out.println(readObj);

    }
}
```

### 8. XML - 객체 Serialize
```java
package com.thj;
import java.beans.XMLEncoder;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class XMLSerializeTest {
    public static void main(String[] args){
        Student student1 = new Student();
        student1.setRollno(1);
        student1.setName("sample1");
        Student student2 = new Student();
        student2.setRollno(2);
        student2.setName("sample2");
        List<Student> s = new ArrayList<>();
        s.add(student1);
        s.add(student2);
        College c = new College();
        c.setStudents(s);
        String strFileName = "/Users/jeongjunghwan/Downloads/SampleSerial.xml";
        try(BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(strFileName))){
            XMLEncoder encoder = new XMLEncoder(bufferedOutputStream);
            encoder.writeObject(c);
            encoder.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.thj;
import java.util.List;
public class College {
    private List<Student> students;
    public List<Student> getStudents() {
        return students;
    }
    public void setStudents(List<Student> students) {
        this.students = students;
    }
}

package com.thj;
public class Student {
    private int rollno;
    private String name;
    public int getRollno() {
        return rollno;
    }
    public void setRollno(int rollno) {
        this.rollno = rollno;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

### 9. XML - 파일 잠그기
```java
package com.thj;
import java.io.FileOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
public class FileLockTest {
    public static void main(String[] args){
        try(FileOutputStream out = new FileOutputStream("/Users/jeongjunghwan/Downloads/sample.txt");
            FileChannel channel = out.getChannel()) {
            FileLock lock = channel.lock();
            try{
                ByteBuffer byteBuffer = ByteBuffer.allocate(10);
                byteBuffer.put(0, (byte)10);
                byteBuffer.put(1, (byte)12);
                byteBuffer.put(2, (byte)33);
                channel.write(byteBuffer);
            }finally {
                lock.release();
            }

        }catch (Exception ex){
        }
    }
}
```

---
