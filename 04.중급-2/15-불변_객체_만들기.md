# 🧠 불변 객체란?
- **불변 객체(Immutable Object)** 는 생성 이후 상태가 절대 변경되지 않는 객체입니다.
- 멀티스레드 환경에서 안전하고, 예측 가능한 동작을 보장합니다.
- 대표적인 예: String, Integer, LocalDate 등

## 코드
```java
class ImmutableIntArray {
    private final int[] array;
    public ImmutableIntArray(int[] array){
        this.array = array.clone();
    }
    public int[] getValue(){
        return array.clone();
    }
}

public class ImmutableTest {
    public static void main(String[] args){
        int[] values ={ 1, 2, 3, 4};
        ImmutableIntArray immutableIntArray = new ImmutableIntArray(values);
        int[] newValues = immutableIntArray.getValue();
        System.out.println(values);
        System.out.println(newValues);
        
    }
}
```

## ✅ 단계별 코드 설명
### 🔹 1. 클래스 선언 및 필드 정의
```java
class ImmutableIntArray {
    private final int[] array;
```

- private final로 선언함으로써 외부에서 접근하거나 변경할 수 없게 만듭니다.
- final은 한 번만 초기화 가능하다는 의미입니다.

### 🔹 2. 생성자에서 깊은 복사 (clone)
```java
public ImmutableIntArray(int[] array){
    this.array = array.clone();
}
```

- array.clone()을 통해 깊은 복사를 수행합니다.
- 원본 배열의 참조를 그대로 저장하면 외부에서 값을 바꿀 수 있으므로, 복사본을 저장해야 불변성이 유지됩니다.

### 🔹 3. Getter에서도 깊은 복사
```java
public int[] getValue(){
    return array.clone();
}
```

- 내부 배열을 그대로 반환하면 외부에서 수정 가능하므로, 복사본을 반환합니다.
- 이로써 외부에서 getValue()를 통해 얻은 배열을 수정해도 원본은 안전하게 유지됩니다.

### 🔹 4. 테스트 코드
```java
public class ImmutableTest {
    public static void main(String[] args){
        int[] values = {1, 2, 3, 4};
        ImmutableIntArray immutableIntArray = new ImmutableIntArray(values);
        int[] newValues = immutableIntArray.getValue();
        System.out.println(values);
        System.out.println(newValues);
    }
}
```

- ImmutableIntArray 객체를 생성하고, 내부 배열을 가져와 출력합니다.
- values와 newValues는 값은 같지만 서로 다른 객체입니다.

## 🔒 불변 객체의 핵심 규칙

| 항목             | 설명                                               | 예시 또는 비고                     |
|------------------|----------------------------------------------------|------------------------------------|
| `final` 키워드   | 필드가 재할당되지 않도록 선언                      | `private final int value;`         |
| 생성자에서 초기화 | 모든 필드는 생성자에서 한 번만 초기화되어야 함     | 생성자 외에서 값 변경 금지         |
| setter 금지      | 필드 값을 변경하는 setter 메서드를 제공하지 않음   | `getValue()`만 제공                |
| 깊은 복사        | 가변 객체를 포함할 경우, 복사본을 만들어 저장       | `new ArrayList<>(originalList)`    |
| 외부 노출 금지   | 내부 가변 객체를 외부에 직접 반환하지 않음         | 복사본 반환 또는 불변 컬렉션 사용  |
| 동기화 고려       | 멀티스레드 환경에서 안전하게 사용될 수 있도록 설계 | `final` + 불변성으로 동기화 불필요 |

## 💼 실전 활용 예시
### 1. 멀티스레드 환경에서 안전한 데이터 공유
```java
ImmutableIntArray sharedData = new ImmutableIntArray(new int[]{1, 2, 3});
```
- 여러 스레드가 동시에 접근해도 데이터가 변경되지 않음.

### 2. 불변 설정값 객체
```java
class AppConfig {
    private final String mode;
    private final int timeout;
    // 생성자, getter만 존재
}
```

- 설정값을 불변으로 유지하면 예기치 않은 변경을 방지.
### 3. 캐시 키로 사용
```java
Map<ImmutableIntArray, String> cache = new HashMap<>();
```

- 불변 객체는 equals()와 hashCode()를 안정적으로 구현할 수 있어 캐시 키로 적합.

## 🧪 확장 예제: 불변 리스트
```java
class ImmutableListWrapper {
    private final List<String> list;

    public ImmutableListWrapper(List<String> input) {
        this.list = List.copyOf(input); // Java 10 이상
    }

    public List<String> getList() {
        return List.copyOf(list);
    }
}
```

- List.copyOf()는 불변 리스트를 생성합니다.

---



