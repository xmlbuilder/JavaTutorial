# 재귀적 데이터 구조
이 구조는 `Composite Pattern` 의 핵심 아이디어를 잘 반영.  
아래에 이 코드가 어떻게 `Composite Pattern` 과 연결되는지, 그리고 어떤 특징을 갖는지 단계별로 설명.

## 🌳 `Composite Pattern` 이란?
Composite Pattern은 객체를 트리 구조로 구성하여 부분-전체 관계를 동일하게 다룰 수 있도록 하는 디자인 패턴.
- `Component`: 공통 인터페이스 또는 추상 클래스
- `Leaf`: 실제 동작을 수행하는 단일 객체
- `Composite`: 자식들을 포함하고, 공통 인터페이스를 구현

## 전체 코드
```java
package com.thj;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class CompositeTest {

    public abstract class Tree<T extends Tree>{
        public Tree(T parent){
            this.parent = parent;
            childrens = new ArrayList<>();
            if(parent != null){
                parent.childrens.add(this);
            }
        }

        public int getLevel() {
            return parent == null ? 0 : parent.getLevel() + 1;
        }

        public boolean isLeaf() {
            return childrens.size() == 0;
        }

        public boolean isRoot() {
            return parent == null;
        }

        public T parent;
        public List<T> childrens;

    }

    public class MyNode extends Tree<MyNode>{
        public MyNode(MyNode parent) {
            super(parent);
        }
    }

    /*
    Compile Error!!!
    public class MyInt extends Tree<Integer>{
        public MyInt(Integer parent) {
            super(parent);
        }
    }*/

    public static void main(String[] args) {
        CompositeTest.MyNode root = new CompositeTest().new MyNode(null);
        CompositeTest.MyNode child1 = new CompositeTest().new MyNode(root);
        CompositeTest.MyNode child2 = new CompositeTest().new MyNode(child1);
        System.out.println(child2.getLevel());
    }
}
```

## 🔍 코드 분석: Composite Pattern 요소

### ✅ 1. Tree<T extends Tree> → Component 역할
```java
public abstract class Tree<T extends Tree> {
    public T parent;
    public List<T> childrens;
}
```
- 공통 기능 (getLevel(), isLeaf(), isRoot())을 정의
- 자식 노드를 리스트로 관리 → 트리 구조 형성

### ✅ 2. MyNode extends Tree<MyNode> → Composite & Leaf 역할
```java
public class MyNode extends Tree<MyNode> {
    public MyNode(MyNode parent) {
        super(parent);
    }
}
```
- MyNode는 자기 자신을 타입으로 지정 → 재귀적 구조
- 자식이 없으면 Leaf, 자식이 있으면 Composite 역할 수행

## 🧠 핵심 특징
| 구성 요소                        | 설명                                                                 |
|----------------------------------|----------------------------------------------------------------------|
| `parent`, `childrens`            | 트리 구조를 구성하는 부모-자식 관계 필드                             |
| `Tree<T extends Tree>`, `MyNode extends Tree<MyNode>` | 재귀적 제네릭 타입을 통한 구조적 확장성                             |
| `Tree.getLevel()`, `isLeaf()`    | 공통 기능 제공: 깊이 계산, 리프 여부 확인                            |
| `parent.childrens.add(this)`     | 생성 시 부모 노드에 자신을 자동으로 추가하여 트리 연결               |


## 🚫 왜 MyInt extends Tree<Integer>는 오류일까?
```java
public class MyInt extends Tree<Integer> { ... }
```
- Integer는 Tree를 상속하지 않음 → T extends Tree 제약 조건 위반
- Tree<T>는 T가 Tree의 하위 타입이어야 함 → 재귀적 타입 필요

### 🧪 실행 예시
```java
CompositeTest.MyNode root = new CompositeTest().new MyNode(null);
LockTest.MyNode child1 = new CompositeTest().new MyNode(root);
CompositeTest.MyNode child2 = new CompositeTest().new MyNode(child1);
System.out.println(child2.getLevel()); // 출력: 2
```
- child2는 root → child1 → child2 구조의 3단계 중 마지막
- getLevel()은 부모를 따라 재귀적으로 깊이를 계산

## ✨ 요약
| 역할       | 클래스/구조                   |
|------------|-------------------------------|
| Component  | `Tree<T extends Tree>`        |
| Composite  | `MyNode` (자식이 있는 경우)    |
| Leaf       | `MyNode` (자식이 없는 경우)    |

---



