# 추상 클래스의 상속과 초기화 순서
이 코드는 Java에서 추상 클래스의 상속과 초기화 순서에 대한 중요한 개념을 보여주는 예제.  
아래에 두 부분으로 나눠서 핵심을 정리:

## 🧠 1. 추상 클래스 상속과 메서드 구현
### ✅ 코드 요약
```java
public abstract class AbstractClass {
    public abstract int calculate(int value1, int value2);
    public void execute() {
        System.out.println(calculate(10, 20));
    }
}

public class SubAbsClass extends AbstractClass {
    @Override
    public int calculate(int value1, int value2) {
        return value1 + value2;
    }
}
```

### ✅ 핵심 개념
- AbstractClass는 추상 메서드 calculate()를 정의하고, execute()에서 이를 호출
- SubAbsClass는 calculate()를 구현하여 execute()를 통해 동작 가능
- **다형성(polymorphism)** 을 활용한 구조로, execute()는 구현된 calculate()를 호출

## ⚠️ 2. 초기화 순서 주의: 생성자에서 추상 메서드 호출
### ✅ 문제 코드 요약
```java
public abstract class Abstract1Class {
    public Abstract1Class() {
        init(); // 위험: 생성자에서 추상 메서드 호출
    }
    abstract void init();
}

public class Abstract1Impl extends Abstract1Class {
    private final String message;

    public Abstract1Impl(String str) {
        this.message = str;
    }

    @Override
    void init() {
        System.out.println("message " + message); // message는 아직 초기화되지 않음
    }
}
```

### ✅ 핵심 경고
- 슈퍼클래스 생성자가 먼저 실행되므로, init() 호출 시 message는 아직 초기화되지 않은 상태
- 결과적으로 message는 `null` 로 출력되거나 예기치 않은 동작 발생
- 생성자에서 추상 메서드나 오버라이드된 메서드 호출은 위험함

## 📌 요약 정리

| 항목                     | 설명 |
|--------------------------|------|
| 추상 클래스 (`abstract`) | 구현 강제: 하위 클래스에서 반드시 메서드 구현 필요 |
| 메서드 오버라이딩        | 상위 클래스에서 정의된 추상 메서드를 하위 클래스가 구현 |
| 초기화 순서              | 상위 클래스 생성자 → 하위 클래스 생성자 순으로 실행됨 |
| 생성자 내 메서드 호출    | 위험: 상위 생성자에서 추상/오버라이드 메서드 호출 시 하위 필드가 초기화되기 전일 수 있음 |

- 이 패턴은 실무에서도 자주 발생하는 실수 중 하나. 
- 생성자에서 this를 통해 오버라이드된 메서드를 호출하는 건 피하는 게 안전합니다. 

---

#  안전한 초기화 패턴 / 팩토리 메서드 패턴

지금 문제는 상위 클래스 생성자에서 추상 메서드를 호출하면서 하위 클래스의 필드가 아직 초기화되지 않아 null이 출력되는 상황.  
이건 Java에서 흔히 발생하는 초기화 순서 관련 버그 중 하나.


## ✅ 1. 안전한 초기화 패턴: 생성자에서 추상 메서드 호출 금지
### 🔥 핵심 원칙
- 생성자에서는 절대 추상 메서드나 오버라이드된 메서드를 호출하지 않는다
- 대신, 초기화가 끝난 후 명시적으로 init()을 호출하거나 별도의 초기화 메서드를 사용
### ✅ 개선 예시
```java
public abstract class Abstract1Class {
    public void safeInit() {
        init(); // 생성자 외부에서 호출
    }
    abstract void init();
}

public class Abstract1Impl extends Abstract1Class {
    private final String message;

    public Abstract1Impl(String str) {
        this.message = str;
    }

    @Override
    void init() {
        System.out.println("message: " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        Abstract1Impl obj = new Abstract1Impl("sample");
        obj.safeInit(); // 안전하게 초기화
    }
}
```
- ✅ message가 초기화된 이후에 init()이 호출되므로 안전


## ✅ 2. 팩토리 메서드 패턴으로 초기화 제어
### 🔥 핵심 원칙
- 객체 생성을 **정적 메서드(factory method)** 로 감싸서 초기화 순서를 제어
- 생성자 내부에서는 최소한의 작업만 수행하고, 초기화는 팩토리에서 처리

### ✅ 개선 예시
```java
public abstract class Abstract1Class {
    abstract void init();
}

public class Abstract1Impl extends Abstract1Class {
    private final String message;

    private Abstract1Impl(String str) {
        this.message = str;
    }

    @Override
    void init() {
        System.out.println("message: " + message);
    }

    public static Abstract1Impl create(String str) {
        Abstract1Impl obj = new Abstract1Impl(str);
        obj.init(); // 안전하게 초기화
        return obj;
    }
}

public class Main {
    public static void main(String[] args) {
        Abstract1Impl obj = Abstract1Impl.create("sample");
    }
}
```
- ✅ 생성자에서 init()을 호출하지 않고, 팩토리 메서드에서 안전하게 호출


## 📌 초기화 순서 회피 전략 요약

| 전략                 | 설명 |
|----------------------|------|
| 안전한 초기화 패턴     | 생성자에서 추상/오버라이드 메서드 호출 금지 → 외부에서 명시적으로 `init()` 호출 |
| 팩토리 메서드 패턴     | 객체 생성을 정적 메서드로 감싸고, 생성 후 안전하게 초기화 수행 |
| 생성자 최소화         | 생성자에서는 필드 초기화만 수행하고, 복잡한 로직은 분리 |

- 이 두 방식은 모두 초기화 순서에 따른 버그를 예방하고, 객체 생성을 더 명확하게 제어할 수 있음.


