# 📚 리스트 추상화와 다형성
## ✅ 핵심 개념
- List는 순서가 있고 중복을 허용하는 자료구조.
- MyArrayList와 MyLinkedList는 내부 구현은 다르지만 동일한 기능을 제공.
- 공통 기능을 MyList 인터페이스로 추상화하면 **다형성과 OCP(Open-Closed Principle)** 를 적용할 수 있음.
- 
## ✅ MyList 인터페이스
```java
public interface MyList<E> {
    int size();
    void add(E e);
    void add(int index, E e);
    E get(int index);
    E set(int index, E element);
    E remove(int index);
    int indexOf(E o);
}
```

## ✅ 구현 클래스
- MyArrayList와 MyLinkedList는 MyList를 구현.
- 각 클래스는 내부 자료구조에 따라 성능 특성이 다름:
- MyArrayList: 배열 기반, 앞쪽 삽입/삭제는 느림 → O(n)
- MyLinkedList: 연결 리스트 기반, 앞쪽 삽입/삭제는 빠름 → O(1)

## 🔄 의존관계 주입 (Dependency Injection)
### ✅ 문제 상황
- BatchProcessor가 MyArrayList에 직접 의존하면, MyLinkedList로 변경 시 코드 수정이 필요함.
- 이는 OCP 위반이며, 유연하지 못한 설계.
- 
### ✅ 해결 방법
- BatchProcessor가 MyList 인터페이스에 의존하도록 변경.
- 생성자를 통해 구현체를 주입받음 → 생성자 의존관계 주입
```java
public class BatchProcessor {
    private final MyList<Integer> list;

    public BatchProcessor(MyList<Integer> list) {
        this.list = list;
    }

    public void logic(int size) {
        for (int i = 0; i < size; i++) {
            list.add(0, i); // 앞에 추가
        }
    }
}
```

### ✅ 실행 예시
```java
public class BatchProcessorMain {
    public static void main(String[] args) {
        MyList<Integer> list = new MyArrayList<>(); // 또는 new MyLinkedList<>();
        BatchProcessor processor = new BatchProcessor(list);
        processor.logic(50_000);
    }
}
```

## 📊 성능 비교 결과

| 구현체         | 앞쪽 삽입 50,000회 실행 시간 |
|----------------|------------------------------|
| MyArrayList     | 약 1361ms                    |
| MyLinkedList    | 약 2ms                       |

- MyLinkedList는 앞쪽 삽입에 최적화되어 있어 성능이 압도적으로 우수.
- 전략을 런타임에 선택할 수 있어 유연하고 확장 가능한 설계가 가능.

## ✅ 구조 정리

| 구성 요소         | 설명                                                  |
|------------------|-------------------------------------------------------|
| `MyList`         | 리스트 기능을 추상화한 인터페이스. 다형성의 핵심       |
| `BatchProcessor` | `MyList`에 의존하는 클라이언트. 생성자 주입 방식 사용 |
| `MyArrayList`    | 배열 기반 리스트 구현체. 앞쪽 삽입 시 O(n) 성능        |
| `MyLinkedList`   | 연결 리스트 기반 구현체. 앞쪽 삽입 시 O(1) 성능        |

---

# 🧠 리스트 추상화와 설계 원칙
## ✅ 핵심 개념
- List: 순서가 있고 중복을 허용하는 자료구조
- MyArrayList와 MyLinkedList: 기능은 같지만 내부 구현이 다름
- 공통 기능을 MyList 인터페이스로 추상화 → 다형성과 OCP 원칙 적용

## 🔄 컴파일 타임 vs 런타임 의존관계

| 구분               | 의존 대상                          | 설명                                                                 |
|--------------------|------------------------------------|----------------------------------------------------------------------|
| 컴파일 타임 의존관계 | `MyList` 인터페이스                | 코드에 명시된 타입. 컴파일 시점에 자바 컴파일러가 인식하는 의존관계 |
| 런타임 의존관계     | `MyArrayList`, `MyLinkedList` 구현체 | 실행 시점에 실제로 주입된 인스턴스에 대한 의존관계                   |


- BatchProcessor는 MyList에만 의존 → 구현체 교체 시 코드 변경 없음
- 생성자를 통해 구현체를 주입 → 생성자 의존관계 주입(DI)

## 🧩 전략 패턴 적용

| 구성 요소         | 역할 설명                                                   |
|------------------|-------------------------------------------------------------|
| `MyList`         | 전략 인터페이스. 리스트 기능을 추상화하여 공통 API 제공       |
| `MyArrayList`    | 전략 구현체 1. 배열 기반 리스트 구현                         |
| `MyLinkedList`   | 전략 구현체 2. 연결 리스트 기반 구현                         |
| `BatchProcessor` | 전략을 사용하는 클라이언트. `MyList`에만 의존하여 유연성 확보 |

- 전략 패턴을 통해 알고리즘을 런타임에 교체 가능
- 클라이언트 코드 변경 없이 다양한 리스트 전략 적용 가능

## 📊 성능 비교 요약

| 기능             | MyArrayList (배열 기반) | MyLinkedList (연결 리스트 기반) |
|------------------|--------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 1369ms         | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 651ms          | O(n) – 약 1112ms                 |
| 뒤에 추가/삭제   | O(1) – 약 2ms            | O(n) – 약 2195ms                 |
| 인덱스 조회       | O(1) – 평균 0~1ms        | O(n) – 평균 438ms                |
| 검색             | O(n) – 평균 115ms        | O(n) – 평균 492ms                |


## 🧠 성능 해설
- 배열 리스트: 메모리 연속 배치 → CPU 캐시 효율 높음, 조회 빠름
- 연결 리스트: 노드 분산 → 참조 변경은 빠르지만 조회/검색은 느림
- 실제 성능은 시간 복잡도 외에도 메모리 접근 방식, 캐시 최적화 등 시스템 요인에 영향 받음

## ✅ 최종 정리

| 구성 요소         | 역할 및 설명                                                   |
|------------------|----------------------------------------------------------------|
| `MyList`         | 리스트 기능을 추상화한 인터페이스. 전략의 기준이 되는 추상 타입 |
| `MyArrayList`    | 배열 기반 리스트 구현체. 빠른 조회, 느린 앞쪽 삽입               |
| `MyLinkedList`   | 연결 리스트 기반 구현체. 빠른 앞쪽 삽입, 느린 조회               |
| `BatchProcessor` | `MyList`에 의존하는 클라이언트. 생성자 주입으로 전략 선택 가능   |

## 🧠 핵심 요약
- MyList는 전략 패턴의 인터페이스 역할
- MyArrayList, MyLinkedList는 전략의 구체적인 구현
- BatchProcessor는 전략을 런타임에 주입받아 사용
- 클라이언트 코드 변경 없이 구현체 교체 가능 → OCP 원칙 준수
- 성능 요구에 따라 전략을 선택할 수 있음 → 유연하고 확장 가능한 설계

---

# 📚 자바 ArrayList와 LinkedList 성능 비교

자바 리스트 구조와 성능 비교를 정리하면, 대부분의 상황에서 ArrayList가 성능상 유리하며,  
앞쪽 삽입/삭제가 빈번한 경우에만 LinkedList를 고려하는 것이 좋습니다.  
아래에 List 인터페이스의 주요 메서드와 성능 비교를 표로 정리했습니다. 


## 📘 List 인터페이스 주요 메서드
| 메서드                                | 설명                                                                 |
|--------------------------------------|----------------------------------------------------------------------|
| `add(E e)`                           | 리스트 끝에 요소 추가                                                |
| `add(int index, E element)`          | 지정된 위치에 요소 삽입                                              |
| `addAll(Collection<? extends E> c)`  | 컬렉션의 모든 요소를 리스트 끝에 추가                                |
| `addAll(int index, Collection<? extends E> c)` | 컬렉션의 모든 요소를 지정된 위치에 삽입                    |
| `get(int index)`                     | 지정된 위치의 요소 반환                                              |
| `set(int index, E element)`          | 지정된 위치의 요소 변경                                              |
| `remove(int index)`                  | 지정된 위치의 요소 제거                                              |
| `remove(Object o)`                   | 지정된 첫 번째 요소 제거                                             |
| `clear()`                            | 모든 요소 제거                                                       |
| `indexOf(Object o)`                  | 첫 번째 인덱스 반환                                                  |
| `lastIndexOf(Object o)`              | 마지막 인덱스 반환                                                   |
| `contains(Object o)`                 | 요소 포함 여부 확인                                                  |
| `sort(Comparator<? super E> c)`      | 비교자 기준으로 정렬                                                |
| `subList(int fromIndex, int toIndex)`| 부분 리스트 뷰 반환                                                  |
| `size()`                             | 요소 수 반환                                                         |
| `isEmpty()`                          | 리스트가 비어있는지 확인                                            |
| `iterator()`                         | 반복자 반환                                                          |
| `toArray()`                          | 배열로 반환                                                          |
| `toArray(T[] a)`                     | 지정된 배열로 반환                                                   |

## 📊 직접 구현한 MyArrayList vs MyLinkedList 성능 비교

| 기능             | MyArrayList (배열 기반)       | MyLinkedList (단일 연결 리스트) |
|------------------|-------------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 1369ms              | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 651ms               | O(n) – 약 1112ms                 |
| 뒤에 추가/삭제   | O(1) – 약 2ms                 | O(n) – 약 2195ms                 |
| 인덱스 조회       | O(1) – 평균 1ms               | O(n) – 평균 438ms                |
| 검색             | O(n) – 평균 115ms            | O(n) – 평균 492ms                |


## 📊 자바 ArrayList vs LinkedList 성능 비교
| 기능             | ArrayList (배열 기반)         | LinkedList (이중 연결 리스트)    |
|------------------|-------------------------------|----------------------------------|
| 앞에 추가/삭제   | O(n) – 약 106ms               | O(1) – 약 2ms                    |
| 중간 추가/삭제   | O(n) – 약 49ms                | O(n) – 약 1116ms                 |
| 뒤에 추가/삭제   | O(1) – 약 1ms                 | O(1) – 약 2ms                    |
| 인덱스 조회       | O(1) – 평균 1ms               | O(n) – 평균 439ms                |
| 검색             | O(n) – 평균 104ms            | O(n) – 평균 473ms                |


## 🧠 성능 요약 및 실무 팁
- ArrayList는 메모리 연속 배치와 고속 복사 덕분에 조회와 평균 삽입 성능이 우수함.
- LinkedList는 앞쪽 삽입/삭제에 최적화되어 있으나, 조회/검색은 느림.
- 자바의 LinkedList는 이중 연결 리스트로 구현되어 있어 마지막 노드 참조와 역방향 탐색이 가능함.
- 실무에서는 대부분 ArrayList를 기본으로 사용하며, 앞쪽 삽입/삭제가 많을 경우에만 LinkedList를 고려.

---

# 📘 문제와 풀이 1: 배열 → 리스트 변경

## ✅ 문제1: 배열을 리스트로 변경하기
| 자료 구조 유형 | 선언 방식                                      |
|----------------|------------------------------------------------|
| 배열           | `int[] students = {90, 80, 70, 60, 50};`        |
| 리스트         | `List<Integer> students = new ArrayList<>();`   |

### 📘 핵심 코드 요약
```java
List<Integer> students = new ArrayList<>();
students.add(90); students.add(80); ...
```

## ✅ 문제2: 리스트 입력과 출력
| 항목         | 설명                                      |
|--------------|-------------------------------------------|
| 입력 구조     | `List<Integer>` 사용                      |
| 종료 조건     | `0` 입력 시 입력 종료                     |
| 출력 형식     | `1, 2, 3, 4, 5` (마지막 쉼표 없음)         |

### 📘 핵심 코드 요약
```java
List<Integer> numbers = new ArrayList<>();
while (true) {
    int input = scanner.nextInt();
    if (input == 0) break;
    numbers.add(input);
}
for (int i = 0; i < numbers.size(); i++) {
    System.out.print(numbers.get(i));
    if (i < numbers.size() - 1) System.out.print(", ");
}
```


## ✅ 문제3: 리스트 합계와 평균

| 항목         | 설명                                      |
|--------------|-------------------------------------------|
| 입력 구조     | 사용자 입력을 `List<Integer>`에 저장       |
| 종료 조건     | `0` 입력 시 입력 종료                     |
| 처리 방식     | 반복문으로 합계 계산 후 평균 도출          |
| 출력 결과     | 합계: 15, 평균: 3.0 (예시 기준)            |


### 📘 핵심 코드 요약
```java
List<Integer> numbers = new ArrayList<>();
while (true) {
    int input = scanner.nextInt();
    if (input == 0) break;
    numbers.add(input);
}
int sum = 0;
for (Integer number : numbers) {
    sum += number;
}
double average = (double) sum / numbers.size();
System.out.println("입력한 정수의 합계: " + sum);
System.out.println("입력한 정수의 평균: " + average);
```

## 🛒 문제와 풀이 2: 리스트 기반 쇼핑카트
### ✅ Item 클래스 구성

| 필드 / 메서드       | 설명                                |
|---------------------|-------------------------------------|
| `name`              | 상품명 (예: "마늘", "상추")          |
| `price`             | 단가 (예: 2000원)                    |
| `quantity`          | 수량 (예: 2개, 4개 등)               |
| `getTotalPrice()`   | `price × quantity`로 총합 계산       |

### 📘 핵심 코드 요약
```java
public class Item {
    private String name;
    private int price;
    private int quantity;

    public Item(String name, int price, int quantity) {
        this.name = name;
        this.price = price;
        this.quantity = quantity;
    }

    public String getName() {
        return name;
    }

    public int getTotalPrice() {
        return price * quantity;`
    }
}
```
## ✅ ShoppingCart 클래스 구성

| 구성 요소                  | 설명                                                              |
|---------------------------|-------------------------------------------------------------------|
| `List<Item> items`        | 장바구니에 담긴 상품들을 저장하는 리스트                          |
| `addItem(Item item)`      | 장바구니에 상품을 추가하는 메서드                                 |
| `displayItems()`          | 장바구니에 담긴 상품들을 출력하고 전체 가격 합계를 계산하는 메서드 |

### 📘 핵심 코드 요약
```java
private List<Item> items = new ArrayList<>();

public void addItem(Item item) {
    items.add(item);
}

public void displayItems() {
    System.out.println("장바구니 상품 출력");
    for (Item item : items) {
        System.out.println("상품명:" + item.getName() + ", 합계:" + item.getTotalPrice());
    }
    System.out.println("전체 가격 합:" + calculateTotalPrice());
}

private int calculateTotalPrice() {
    int totalPrice = 0;
    for (Item item : items) {
        totalPrice += item.getTotalPrice();
    }
    return totalPrice;
}
```

## ✅ 배열과 리스트 비교

| 항목               | 배열 방식 (`Item[]`)           | 리스트 방식 (`List<Item>`)         |
|--------------------|-------------------------------|-------------------------------------|
| 크기 관리 방식     | `itemCount`로 수동 추적        | `size()` 메서드로 자동 관리         |
| 초기 크기 설정     | 고정 크기 필요 (`new Item[10]`) | 크기 제한 없음 (자동 확장)          |
| 요소 추가 방식     | 인덱스 직접 지정 (`items[i]`)  | `add()` 메서드 사용                 |
| 요소 제거 방식     | 직접 null 처리 및 인덱스 이동  | `remove()` 메서드로 간편 처리       |
| 반복 처리 방식     | `for (int i = 0; i < itemCount; i++)` | `for (Item item : items)` 또는 `forEach` |
| 유연성 및 확장성   | 제한적, 배열 크기 초과 시 오류  | 유연함, 필요 시 자동 확장           |

## ✅ 핵심 요약
- 배열보다 리스트를 사용하면 동적 크기 관리, 코드 간결성, 확장성 측면에서 유리함
- ArrayList는 순차 접근과 조회에 강점, LinkedList는 앞쪽 삽입/삭제에 강점
- 실무에서는 대부분 ArrayList를 기본으로 사용하며, 상황에 따라 LinkedList를 전략적으로 선택

---

