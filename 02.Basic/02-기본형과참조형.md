# 🧬 기본형과 참조형

## 1️⃣ 기본형과 참조형이란?
자바의 변수 타입은 크게 두 가지로 나뉜다:
| 구분     | 설명                                      |
|----------|-------------------------------------------|
| 기본형   | 값을 직접 저장하는 타입 (`int`, `double`) |
| 참조형   | 객체나 배열의 위치(주소)를 저장하는 타입  |
- 기본형은 값 자체를 저장
- 참조형은 객체나 배열의 참조값(주소) 를 저장

## 2️⃣ 기본형 vs 참조형 - 구조
### 기본형
```java
int a = 10; // 변수 a에 값 10 저장
```
- 변수에 값이 직접 들어있음

## 참조형
```java
Student s1 = new Student(); // 변수 s1에 객체의 참조값 저장
```
- 변수에는 객체의 위치(주소)가 들어있음
- 객체에 접근하려면 . 연산자 사용

## 3️⃣ 기본형 vs 참조형 - 계산
### 기본형은 연산 가능
```java
int a = 10;
int b = 20;
int sum = a + b; // OK
```

### 참조형은 연산 불가능
```java
Student s1 = new Student();
Student s2 = new Student();
Student result = s1 + s2; // ❌ 오류 발생
```

### 단, 객체 내부의 기본형은 연산 가능
```java
s1.grade = 100;
s2.grade = 90;
int sum = s1.grade + s2.grade; // OK
```


## 4️⃣ 기본형 vs 참조형 - 변수 대입
### 대원칙
- 자바는 항상 변수에 들어있는 값을 복사해서 대입한다.

#### 기본형 대입
```java
int a = 10;
int b = a; // 값 10 복사
```

- 변수 a의 값이 b에 복사됨
- 이후 a, b는 독립적으로 동작

#### 참조형 대입
```java
Student s1 = new Student();
Student s2 = s1; // 참조값 복사
```

- 변수 s1의 참조값이 s2에 복사됨
- s1, s2는 같은 객체를 참조

## 5️⃣ 실전 예제: 기본형 대입
```java
int a = 10;
int b = a;

a = 20;
b = 30;

System.out.println("a = " + a); // 20
System.out.println("b = " + b); // 30
```

a와 b는 서로 독립적인 값


## 6️⃣ 실전 예제: 참조형 대입
### 클래스 정의
```java
public class Data {
    int value;
}
```

### 코드
```java
Data dataA = new Data();
dataA.value = 10;

Data dataB = dataA; // 참조값 복사

dataA.value = 20;
System.out.println(dataB.value); // 20

dataB.value = 30;
System.out.println(dataA.value); // 30
```
- dataA와 dataB는 같은 객체를 참조하므로 값이 함께 변경됨

## 📥 정리
| 항목         | 기본형                         | 참조형                              |
|--------------|--------------------------------|-------------------------------------|
| 저장 방식     | 값 자체 저장                   | 객체나 배열의 참조값 저장           |
| 연산 가능 여부| 가능 (`+`, `-`, 등)            | 불가능 (단, 내부 값은 가능)         |
| 대입 방식     | 값 복사                        | 참조값 복사                         |
| 독립성        | 변수 간 독립적                 | 변수 간 동일 객체 참조              |
| 예시 타입     | `int`, `double`, `boolean`     | `Student`, `String`, `int[]` 등     |

- 기본형은 값 중심, 참조형은 객체 중심. 이 차이를 이해하면 자바의 메모리 구조와 객체 관리가 훨씬 쉬움.

---

# 🧬 기본형 vs 참조형: 메서드 호출 방식 비교

## 1️⃣ 자바의 대원칙
자바는 항상 변수에 들어 있는 값을 복사해서 전달한다.
- 기본형: 값 자체를 복사
- 참조형: 객체의 참조값(주소)을 복사
이 원칙은 변수 대입뿐 아니라 메서드 호출 시 매개변수 전달에도 동일하게 적용된다.

## 2️⃣ 기본형의 메서드 호출
### 예제 코드
```java
public class MethodChange1 {
    public static void main(String[] args) {
        int a = 10;
        System.out.println("메서드 호출 전: a = " + a);
        changePrimitive(a);
        System.out.println("메서드 호출 후: a = " + a);
    }

    static void changePrimitive(int x) {
        x = 20;
    }
}
```

### 실행 결과
```
메서드 호출 전: a = 10
메서드 호출 후: a = 10
```

### 동작 설명
- changePrimitive(a) 호출 시 x = a → 값 10 복사
- x = 20으로 변경해도 a에는 영향 없음
- 메서드 종료 시 x는 사라지고 a는 그대로 유지

## 3️⃣ 참조형의 메서드 호출
### 클래스 정의
```java
public class Data {
    int value;
}
```

### 예제 코드
```java
public class MethodChange2 {
    public static void main(String[] args) {
        Data dataA = new Data();
        dataA.value = 10;
        System.out.println("메서드 호출 전: dataA.value = " + dataA.value);
        changeReference(dataA);
        System.out.println("메서드 호출 후: dataA.value = " + dataA.value);
    }

    static void changeReference(Data dataX) {
        dataX.value = 20;
    }
}
```

### 실행 결과
```
메서드 호출 전: dataA.value = 10
메서드 호출 후: dataA.value = 20
```

동작 설명
- changeReference(dataA) 호출 시 dataX = dataA → 참조값 x001 복사
- dataX.value = 20 → x001 객체의 내부 값 변경
- dataA와 dataX는 같은 객체를 참조하므로 값이 함께 변경됨

## 4️⃣ 비교 요약
| 항목         | 기본형                           | 참조형                              |
|--------------|----------------------------------|-------------------------------------|
| 전달 방식     | 값 자체 복사                     | 참조값(주소) 복사                   |
| 메서드 내부 변경 | 호출자 변수에 영향 없음           | 호출자 객체의 내부 값 변경 가능     |
| 예시 타입     | `int`, `double`, `boolean`       | `Student`, `Data`, `int[]` 등       |
| 메서드 호출 결과 | 원본 값 유지                    | 원본 객체의 상태 변경 가능          |


## 📥 정리
- 자바는 **값에 의한 전달(call by value)**만 지원한다.

## 🔁 참조형과 메서드: 객체 전달과 반환

## 1️⃣ 중복 코드 문제
## 기존 코드
```java
Student student1 = new Student();
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

Student student2 = new Student();
student2.name = "학생2";
student2.age = 16;
student2.grade = 80;
```            

- 객체 생성과 초기화가 반복됨
- 출력 코드도 중복됨

## 2️⃣ 객체를 메서드로 전달
### 메서드 정의
```java
static void initStudent(Student student, String name, int age, int grade) {
    student.name = name;
    student.age = age;
    student.grade = grade;
}
```

### 메서드 호출
```java
Student student1 = new Student();
initStudent(student1, "학생1", 15, 90);
```

### 원리 설명
- student1의 참조값이 initStudent()의 매개변수 student에 복사됨
- student를 통해 student1이 참조하는 객체에 접근하여 값을 설정
- 참조형은 메서드에 전달될 때 참조값이 복사되므로, 메서드 내부에서 객체의 상태를 변경할 수 있음


## 3️⃣ 객체를 메서드에서 반환
### 메서드 정의
```java
static Student createStudent(String name, int age, int grade) {
    Student student = new Student();
    student.name = name;
    student.age = age;
    student.grade = grade;
    return student;
}
```

### 메서드 호출
```java
Student student1 = createStudent("학생1", 15, 90);
```

### 원리 설명
- 메서드 내부에서 객체를 생성하고 초기화
- return을 통해 참조값을 반환
- 반환된 참조값을 변수에 저장하여 외부에서 객체를 사용할 수 있음


## 📥 정리
| 방식             | 설명                                      |
|------------------|-------------------------------------------|
| 객체 전달         | 참조값을 복사하여 메서드에 전달            |
| 객체 내부 변경     | 메서드 내부에서 객체의 상태 변경 가능       |
| 객체 반환         | 메서드에서 생성한 객체의 참조값을 반환      |

- 자바에서 참조형은 메서드 설계에 매우 유용하며, 객체를 전달하거나 반환함으로써 코드의 유연성과 재사용성을 높일 수 있음.

---

# 🧠 자바 변수 초기화와 NullPointerException

## 1️⃣ 지역 변수 vs 멤버 변수
### 지역 변수 (Local Variable)
- 메서드 내부에서 선언
- 반드시 직접 초기화해야 함
- 메서드 종료 시 제거됨
```java
void changePrimitive(int x) {
    x = 20; // x는 지역 변수
}
```

### 멤버 변수 (Field)
- 클래스 내부에서 선언
- 객체 생성 시 자동 초기화
- int → 0
- boolean → false
- 참조형 → null
```java
public class InitData {
    int value1;         // 자동 초기화 → 0
    int value2 = 10;    // 명시적 초기화
}
```


## 2️⃣ null의 의미와 사용
### null이란?
- 참조형 변수에 아직 객체를 참조하지 않음을 의미
- 객체 생성 전, 또는 참조 해제 시 사용
```java
Data data = null; // 아직 아무 객체도 참조하지 않음
data = new Data(); // 객체 생성 후 참조
data = null; // 참조 해제
```

### 출력 예시
```
1. data = null
2. data = ref.Data@x001
3. data = null
```


## 3️⃣ GC와 참조 해제
### 가비지 컬렉션(GC)
- 자바는 사용되지 않는 객체를 자동으로 제거
- 객체가 더 이상 참조되지 않으면 GC 대상이 됨
```java
Data data = new Data(); // x001 생성
data = null;            // x001 참조 해제 → GC 대상
```
- C 언어처럼 수동으로 메모리 해제하지 않아도 됨


## 4️⃣ NullPointerException
### 발생 원리
- null 참조에 . (dot)을 사용하면 예외 발생
- 즉, 주소가 없는 객체를 참조하려고 할 때
```java
Data data = null;
data.value = 10; // ❌ NullPointerException
```

### 예외 메시지
```
Exception in thread "main" java.lang.NullPointerException: Cannot assign field "value" because "data" is null
```

### 멤버 변수의 null
```java
public class Data {
int value;
}

public class BigData {
Data data;
int count;
}

BigData bigData = new BigData();
System.out.println(bigData.data.value); // ❌ data는 null
```

### 해결 방법
```java
bigData.data = new Data(); // 객체 생성 후 참조
System.out.println(bigData.data.value); // ✅ 0 출력
```

## 📥 정리
| 항목               | 설명                                      |
|--------------------|-------------------------------------------|
| 지역 변수           | 직접 초기화 필요, 메서드 종료 시 제거      |
| 멤버 변수           | 자동 초기화, 객체 생성 시 값 설정          |
| null               | 참조값 없음, 객체 미참조 상태              |
| GC                 | 참조되지 않는 객체는 자동 제거             |
| NullPointerException | null에 .(dot) 사용 시 발생하는 예외       |

- NullPointerException은 자바에서 가장 흔한 예외 중 하나. null 상태를 잘 관리하면 안정적인 코드를 작성할 수 있어요.

---

# 🛒 상품 주문 시스템 & 기본형 vs 참조형

## 1️⃣ 프로젝트 개요
- 온라인 상점의 주문 관리 시스템 개발
- 상품 정보를 객체로 관리
- 배열과 메서드를 활용해 구조화
- 사용자 입력을 통해 주문 정보 수집

## 2️⃣ 클래스 설계
### ProductOrder 클래스
```java
package ref.ex;

public class ProductOrder {
    String productName;
    int price;
    int quantity;
}
```

- 상품명, 가격, 수량을 멤버 변수로 정의
- 하나의 주문 정보를 객체로 표현

## 3️⃣ 기본 주문 시스템
### ProductOrderMain2 예제
```java
ProductOrder[] orders = new ProductOrder[3];
orders[0] = createOrder("두부", 2000, 2);
orders[1] = createOrder("김치", 5000, 1);
orders[2] = createOrder("콜라", 1500, 2);
printOrders(orders);
int totalAmount = getTotalAmount(orders);
System.out.println("총 결제 금액: " + totalAmount);
```

### 메서드 구조
```java
static ProductOrder createOrder(String name, int price, int quantity)
static void printOrders(ProductOrder[] orders)
static int getTotalAmount(ProductOrder[] orders)


static ProductOrder createOrder(String productName, int price, int quantity)
{
    ProductOrder order = new ProductOrder();
    order.productName = productName;
    order.price = price;
    order.quantity = quantity;
    return order;
}

static void printOrders(ProductOrder[] orders) {
    for (ProductOrder order : orders) {
        System.out.println("상품명: " + order.productName + ", 가격: " +
        order.price + ", 수량: " + order.quantity);
    }
}

static int getTotalAmount(ProductOrder[] orders) {
    int totalAmount = 0;
    for (ProductOrder order : orders) {
        totalAmount += order.price * order.quantity;
    }
    return totalAmount;
}

```

객체 생성, 출력, 계산을 각각의 메서드로 분리하여 코드의 재사용성과 가독성을 높임


## 4️⃣ 사용자 입력 주문 시스템
### ProductOrderMain3 예제
```java
Scanner scanner = new Scanner(System.in);
System.out.print("입력할 주문의 개수를 입력하세요: ");
int n = scanner.nextInt();
scanner.nextLine();

ProductOrder[] orders = new ProductOrder[n];
for (int i = 0; i < n; i++) {
    System.out.println((i + 1) + "번째 주문 정보를 입력하세요.");
    System.out.print("상품명: ");
    String name = scanner.nextLine();
    System.out.print("가격: ");
    int price = scanner.nextInt();
    System.out.print("수량: ");
    int quantity = scanner.nextInt();
    scanner.nextLine();
    orders[i] = createOrder(name, price, quantity);
}
printOrders(orders);
System.out.println("총 결제 금액: " + getTotalAmount(orders));
```

사용자 입력을 통해 주문 정보를 수집하고 배열에 저장. 이후 출력 및 총액 계산.


## 📥 정리
| 핵심 개념             | 설명                                      |
|------------------------|-------------------------------------------|
| 클래스 활용             | 데이터를 구조화하고 객체로 관리            |
| 배열과 메서드 조합      | 반복되는 작업을 효율적으로 처리            |
| 사용자 입력 처리        | Scanner로 동적 데이터 수집                |
| 기본형 vs 참조형        | 값 vs 주소, 연산 가능 여부, null 처리 차이 |
| 메서드 호출 방식        | 값 복사 → 참조형은 객체 상태 변경 가능     |

자바는 항상 **값에 의한 전달(call by value)**을 사용하지만, 참조형은 참조값을 복사하므로 객체의 상태는 변경될 수 있음


