# 객체 지향 프로그램
절차 지향 프로그래밍에서 객체 지향 프로그래밍으로 점진적으로 전환하는 과정을 설명한 문서의 핵심 내용을 정리한 요약입니다.

## 🎯 프로그래밍 패러다임: 절차 지향 vs 객체 지향
### 🔧 절차 지향 프로그래밍
- 실행 순서(절차)를 중심으로 프로그래밍
- "어떻게 처리할 것인가"에 집중
- 데이터와 처리 로직이 분리되어 있음
- 예: int volume, boolean isOn 같은 변수로 상태 관리
### 🧱 객체 지향 프로그래밍
- 객체를 중심으로 프로그래밍
- "무엇을 다룰 것인가"에 집중
- 데이터와 해당 데이터를 처리하는 기능(메서드)을 하나의 객체로 묶음
- 예: MusicPlayer 클래스 안에 volume, isOn과 관련 메서드 포함

## 🎵 예제: 음악 플레이어 만들기
### 1️⃣ 절차 지향 음악 플레이어 1
- 변수로 상태 관리: volume, isOn
- 순차적으로 기능 수행
- 모든 로직이 main()에 존재

### 코드
```java
public class MusicPlayerMain1 {
    public static void main(String[] args) {
        int volume = 0;
        boolean isOn = false;
        //음악 플레이어 켜기
        isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
        //볼륨 증가
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
        //볼륨 증가
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
        //볼륨 감소
        volume--;
        System.out.println("음악 플레이어 볼륨:" + volume);
        //음악 플레이어 상태
        System.out.println("음악 플레이어 상태 확인");
        if (isOn) {
        System.out.println("음악 플레이어 ON, 볼륨:" + volume);
        } else {
        System.out.println("음악 플레이어 OFF");
        }
        //음악 플레이어 끄기
        isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
}
```
### 실행 결과
```
음악 플레이어를 시작합니다
음악 플레이어 볼륨:1
음악 플레이어 볼륨:2
음악 플레이어 볼륨:1
음악 플레이어 상태 확인
음악 플레이어 ON, 볼륨:1
음악 플레이어를 종료합니다
```

### 2️⃣ 절차 지향 음악 플레이어 2 - 데이터 묶음
- MusicPlayerData 클래스 도입
- 관련 데이터를 하나의 객체로 묶음
- 로직은 여전히 main()에 존재

#### 코드
```java
public class MusicPlayerData {
    int volume = 0;
    boolean isOn = false;
}

public class MusicPlayerMain2 {
    public static void main(String[] args) {
        MusicPlayerData data = new MusicPlayerData();
        //음악 플레이어 켜기
        data.isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
        //볼륨 증가
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        //볼륨 증가
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        //볼륨 감소
        data.volume--;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
        //음악 플레이어 상태
        System.out.println("음악 플레이어 상태 확인");
        if (data.isOn) {
        System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);
        } else {
        System.out.println("음악 플레이어 OFF");
        }
        //음악 플레이어 끄기
        data.isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
}
```

### 3️⃣ 절차 지향 음악 플레이어 3 - 메서드 추출
- 기능별 메서드 분리: on(), off(), volumeUp(), volumeDown(), showStatus()
- 코드 재사용성 및 가독성 향상
- 여전히 데이터와 기능이 분리되어 있음

#### 실제 코드
```java
* 메서드 추출
*/
public class MusicPlayerMain3 {
    public static void main(String[] args) {
        MusicPlayerData data = new MusicPlayerData();
        //음악 플레이어 켜기
        on(data);
        //볼륨 증가
        volumeUp(data);
        //볼륨 증가
        volumeUp(data);
        //볼륨 감소
        volumeDown(data);
        //음악 플레이어 상태
        showStatus(data);
        //음악 플레이어 끄기
        off(data);
    }

    static void on(MusicPlayerData data) {
        data.isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
    }
    static void off(MusicPlayerData data) {
        data.isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
    static void volumeUp(MusicPlayerData data) {
        data.volume++;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
    }
    static void volumeDown(MusicPlayerData data) {
        data.volume--;
        System.out.println("음악 플레이어 볼륨:" + data.volume);
    }
    static void showStatus(MusicPlayerData data) {
        System.out.println("음악 플레이어 상태 확인");
        if (data.isOn) {
            System.out.println("음악 플레이어 ON, 볼륨:" + data.volume);
        } else {
            System.out.println("음악 플레이어 OFF");
        }
    }
}
```

## ⚠️ 절차 지향의 한계
- 데이터(MusicPlayerData)와 기능(MusicPlayerMain3)이 분리되어 있음
- 유지보수 시 두 영역을 모두 수정해야 함
- 기능과 데이터가 밀접하게 연관되어 있음에도 불구하고 분리되어 있어 관리가 복잡함

## 🧠 객체 지향의 핵심
- 데이터와 기능을 하나의 객체로 묶음
- 예: MusicPlayer 클래스 내부에 volume, isOn과 관련 메서드 포함
- 유지보수 용이, 코드 재사용성 증가, 확장성 향상

----


# 🧭 프로그래밍 패러다임 전환 요약
## 1️⃣ 변수만 존재하는 클래스
```java
public class ValueData {
    int value;
}
```

- 데이터만 존재하는 클래스
- 기능은 외부 메서드에서 처리 (add() 메서드)


## 2️⃣ 기능을 포함한 클래스
```java
public class ValueObject {
    int value;
    void add() {
        value++;
        System.out.println("숫자 증가 value=" + value);
    }
}
```

- 데이터와 기능을 하나의 클래스에 포함
- 객체 내부에서 자신의 데이터를 직접 처리

# 🎵 음악 플레이어 예제의 발전 과정
## ✅ 절차 지향 방식
- 데이터: MusicPlayerData 클래스에 volume, isOn
- 기능: MusicPlayerMain 클래스의 static 메서드에서 처리
- 데이터와 기능이 분리되어 있음
## ✅ 객체 지향 방식
```java
public class MusicPlayer {
    int volume = 0;
    boolean isOn = false;

    void on() { ... }
    void off() { ... }
    void volumeUp() { ... }
    void volumeDown() { ... }
    void showStatus() { ... }
}
```

## 전체 소스
```java
public class MusicPlayer {
    int volume = 0;
    boolean isOn = false;
    void on() {
        isOn = true;
        System.out.println("음악 플레이어를 시작합니다");
    }
    void off() {
        isOn = false;
        System.out.println("음악 플레이어를 종료합니다");
    }
    void volumeUp() {
        volume++;
        System.out.println("음악 플레이어 볼륨:" + volume);
    }
    void volumeDown() {
        volume--;
        System.out.println("음악 플레이어 볼륨:" + volume);
    }
    void showStatus() {
        System.out.println("음악 플레이어 상태 확인");
        if (isOn) {
            System.out.println("음악 플레이어 ON, 볼륨:" + volume);
        } else {
            System.out.println("음악 플레이어 OFF");
        }
    }
}
```


```java
public class MusicPlayerMain4 {
    public static void main(String[] args) {
        MusicPlayer player = new MusicPlayer();
        //음악 플레이어 켜기
        player.on();
        //볼륨 증가
        player.volumeUp();
        //볼륨 증가
        player.volumeUp();
        //볼륨 감소
        player.volumeDown();
        //음악 플레이어 상태
        player.showStatus();
        //음악 플레이어 끄기
        player.off();
    }
}
```
### 출력 결과
```
음악 플레이어를 시작합니다
음악 플레이어 볼륨:1
음악 플레이어 볼륨:2
음악 플레이어 볼륨:1
음악 플레이어 상태 확인
음악 플레이어 ON, 볼륨:1
음악 플레이어를 종료합니다
```


- 데이터와 기능을 하나의 클래스에 통합
- 객체 자체가 음악 플레이어의 모든 동작을 책임짐

## 🎯 객체 지향의 핵심 개념
### 🔹 캡슐화 (Encapsulation)
- 관련된 데이터와 기능을 하나의 단위로 묶음
- 외부에서는 내부 구현을 몰라도 기능을 사용할 수 있음
- 유지보수와 확장성이 뛰어남
### 🔹 추상화 (Abstraction)
- 사용자는 복잡한 내부 구조를 몰라도 객체의 기능만 사용
- 예: player.volumeUp()만 호출하면 볼륨이 증가함

## 🧑‍💻 역할 분리
- 음악 플레이어 개발자: MusicPlayer 클래스를 설계
- 음악 플레이어 사용자: MusicPlayer 객체를 생성하고 기능만 호출

## ✅ 결론
- 절차 지향은 실행 순서 중심, 기능과 데이터가 분리됨
- 객체 지향은 객체 중심, 기능과 데이터를 하나로 묶음
- 객체 지향 방식은 코드의 재사용성, 유지보수성, 가독성을 크게 향상시킴

---


## 🧩 문제 요약
### 문제 1: 직사각형 프로그램 객체 지향
- Rectangle 클래스를 만들어 속성과 기능을 객체에 포함
- RectangleOopMain에서 객체 생성 후 메서드 호출

#### 1.절차적 코드
```java
public class RectangleProceduralMain {
    public static void main(String[] args) {
    int width = 5;
    int height = 8;
    int area = calculateArea(width, height);
    System.out.println("넓이: " + area);
    int perimeter = calculatePerimeter(width, height);
    System.out.println("둘레 길이: " + perimeter);
    boolean square = isSquare(width, height);
    System.out.println("정사각형 여부: " + square);
    }

    static int calculateArea(int width, int height) {
        return width * height;
    }

    static int calculatePerimeter(int width, int height) {
        return 2 * (width + height);
    }
    static boolean isSquare(int width, int height) {
    return width == height;
    }
}
```
#### 2. 객체 지향 코드
```java
public class Rectangle {
    int width;
    int height;
    int calculateArea() {
    return width * height;
    }
    int calculatePerimeter() {
    return 2 * (width + height);
    }
    boolean isSquare() {
    return this.width == this.height;
    }
}

public class RectangleOopMain {
    public static void main(String[] args) {
        Rectangle rectangle = new Rectangle();
        rectangle.width = 5;
        rectangle.height = 8;
        int area = rectangle.calculateArea();
        System.out.println("넓이: " + area);
        int perimeter = rectangle.calculatePerimeter();
        System.out.println("둘레 길이: " + perimeter);
        boolean square = rectangle.isSquare();
        System.out.println("정사각형 여부: " + square);
    }
}
```

### 문제 2: 은행 계좌 객체 설계
- Account 클래스: balance 속성, deposit()과 withdraw() 메서드
- 출금 시 잔액 부족하면 메시지 출력
- AccountMain에서 입출금 시나리오 실행


#### 코드

```java
class Account {
    int balance; // 잔액
    void deposit(int amount) {
        balance += amount;
    }
    void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount;
        } else {
            System.out.println("잔액 부족");
        }
    }
}

public class AccountMain {
    public static void main(String[] args) {
        Account account = new Account();
        account.deposit(10000);
        account.withdraw(9000);
        account.withdraw(2000);
        System.out.println("잔고: " + account.balance);
    }
}

```
---

## 정리

## 🧠 객체 지향 vs 절차 지향

| 항목             | 절차 지향 프로그래밍                   | 객체 지향 프로그래밍                     |
|------------------|----------------------------------------|------------------------------------------|
| 중심 개념        | 실행 순서 중심 ("어떻게")              | 객체와 관계 중심 ("무엇을")              |
| 데이터와 기능    | 분리되어 있음                           | 객체 내부에 함께 포함됨                  |
| 설계 방식        | 기능 중심                               | 구조(객체) 중심                          |
| 예시             | 함수로 넓이 계산                        | `Rectangle` 객체가 넓이 계산 기능 포함    |


## 🧱 객체란?
- 속성: 객체가 가진 데이터 (예: 색상, 속도, 레벨)
- 기능: 객체가 수행하는 행동 (예: 이동, 공격, 계산)

## 🎯 객체 지향 vs 절차 지향 예시

| 예시 대상     | 속성 (데이터)                  | 기능 (행동)                  | 프로그래밍 방식 예시         |
|---------------|-------------------------------|------------------------------|------------------------------|
| 자동차        | 색상, 속도                     | 엑셀, 브레이크, 문 열기       | `Car` 클래스의 메서드로 구현 |
| 동물          | 색상, 키, 체온                 | 먹는다, 걷는다                | `Animal` 클래스의 메서드로 구현 |
| 게임 캐릭터   | 레벨, 경험치, 아이템           | 이동, 공격, 아이템 획득       | `Character` 클래스의 메서드로 구현 |



## 🎯 객체 지향의 핵심 특징
- 속성과 기능을 하나의 단위로 묶음
- 캡슐화, 상속, 다형성, 추상화, 메시지 전달 등 다양한 개념 포함
- 실세계 모델링에 유리하며 유지보수와 확장성이 뛰어남
