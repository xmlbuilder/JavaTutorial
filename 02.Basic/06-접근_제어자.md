# 접근 제어자

## 🎯 접근 제어자 이해 1 – 왜 필요한가?
### 📌 개념 요약
- 자바는 `public`, `private`, `protected`, (default) 같은 접근 제어자를 제공함
- 클래스 외부에서 필드나 메서드에 접근할 수 있는 범위를 제어함
- 객체의 내부 상태를 보호하고, 잘못된 사용을 방지하기 위해 사용됨


### 🧩 예제: Speaker 클래스
```java
public class Speaker {
    int volume; // 외부에서 직접 접근 가능 → 위험

    Speaker(int volume) {
        this.volume = volume;
    }

    void volumeUp() {
        if (volume >= 100) {
            System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
        } else {
            volume += 10;
            System.out.println("음량을 10 증가합니다.");
        }
    }

    void volumeDown() {
        volume -= 10;
        System.out.println("volumeDown 호출");
    }

    void showVolume() {
        System.out.println("현재 음량:" + volume);
    }
}
```


#### ⚠️ 문제 상황
- volume 필드가 public이 아니더라도 default 접근이므로 같은 패키지에서 직접 수정 가능
- 새로운 개발자가 speaker.volume = 200;처럼 직접 필드를 수정 → 스피커 고장

### ✅ 해결 방법: private 접근 제어자 사용
```java
public class Speaker {
    private int volume; // 외부 접근 차단

    public Speaker(int volume) {
        this.volume = volume;
    }

    public void volumeUp() {
        if (volume >= 100) {
            System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
        } else {
            volume += 10;
            System.out.println("음량을 10 증가합니다.");
        }
    }

    public void volumeDown() {
        volume -= 10;
        System.out.println("volumeDown 호출");
    }

    public void showVolume() {
        System.out.println("현재 음량:" + volume);
    }
}
```


### ✅ 핵심 메시지
접근 제어자는 객체의 무결성과 안정성을 지키기 위한 필수 도구입니다.  
외부에서 직접 필드를 수정할 수 없도록 막아야, 클래스가 정의한 규칙대로만 동작하게 만들 수 있습니다.



### ⚠️ 잘못된 접근 예시
Speaker speaker = new Speaker(90);
speaker.volume = 200; // ❌ 컴파일 오류: volume has private access


### 📦 정리: 자바 접근 제어자

| 접근 제어자 | 접근 범위                              | 사용 대상               | 설명                                      |
|-------------|----------------------------------------|--------------------------|-------------------------------------------|
| public      | 모든 클래스에서 접근 가능               | 클래스, 필드, 메서드     | 외부에서 자유롭게 사용할 수 있음           |
| private     | 해당 클래스 내부에서만 접근 가능         | 필드, 메서드             | 외부 접근 차단, 내부 상태 보호에 사용       |
| protected   | 같은 패키지 또는 상속 관계에서 접근 가능 | 필드, 메서드             | 상속 구조에서 자식 클래스에게만 공개        |
| (default)   | 같은 패키지 내에서만 접근 가능           | 클래스, 필드, 메서드     | 패키지 내부 전용, 키워드 없이 선언됨        |



### 🧪 실습 예제: AccessData 클래스
#### 📁 패키지: access.a
```java
public class AccessData {
    public int publicField;
    int defaultField;
    private int privateField;

    public void publicMethod() { ... }
    void defaultMethod() { ... }
    private void privateMethod() { ... }

    public void innerAccess() {
        // 내부 접근 → 모든 필드와 메서드 접근 가능
    }
}
```

#### ✅ 같은 패키지 접근: AccessInnerMain
```java
AccessData data = new AccessData();
data.publicField = 1;       // ✅ 가능
data.defaultField = 2;      // ✅ 가능
// data.privateField = 3;   // ❌ 불가능
data.innerAccess();         // ✅ 가능
```

##### ❌ 다른 패키지 접근: AccessOuterMain
```java
AccessData data = new AccessData();
data.publicField = 1;       // ✅ 가능
// data.defaultField = 2;   // ❌ 불가능
// data.privateField = 3;   // ❌ 불가능
data.innerAccess();         // ✅ 가능 (내부에서 private 접근)
```

---

## 📦 클래스 레벨 접근 제어자 정리
### 🎯 정리: 자바 접근 제어자

| 접근 제어자 | 접근 범위                                      | 설명                                                             |
|-------------|------------------------------------------------|------------------------------------------------------------------|
| private     | 해당 클래스 내부에서만 접근 가능                 | 외부 접근 완전 차단, 캡슐화에 가장 적합                           |
| default     | 같은 패키지 내에서만 접근 가능                   | 키워드 없이 선언 시 적용, 패키지 내부 전용                        |
| protected   | 같은 패키지 + 상속 관계 클래스에서 접근 가능     | 상속 구조에서 자식 클래스에게만 공개                             |
| public      | 모든 클래스에서 접근 가능                       | 가장 개방적, 외부에서 자유롭게 호출 가능                         |
| 사용 위치   | 클래스, 필드, 메서드, 생성자                     | 클래스 레벨은 `public` 또는 `default`만 사용 가능                 |
| 핵심 목적   | 정보 은닉과 캡슐화                               | 내부 구현을 숨기고 필요한 기능만 외부에 공개                     |
| 좋은 설계   | 적절한 제약을 통해 안정성과 유지보수성 확보       | 무분별한 공개보다 통제된 접근이 더 안전함                         |

### 🧩 예제: PublicClass.java
```java
package access.a;

public class PublicClass {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();
        DefaultClass1 class1 = new DefaultClass1();
        DefaultClass2 class2 = new DefaultClass2();
    }
}

class DefaultClass1 {
}

class DefaultClass2 {
}
```

- PublicClass는 public → 외부 패키지에서도 접근 가능
- DefaultClass1, DefaultClass2는 default → 같은 패키지에서만 접근 가능
- 하나의 파일에 public 클래스는 하나만 존재 가능
- default 클래스는 여러 개 정의 가능

### 🧪 같은 패키지 접근: PublicClassInnerMain.java
```java
package access.a;

public class PublicClassInnerMain {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();     // ✅ 접근 가능
        DefaultClass1 class1 = new DefaultClass1();       // ✅ 접근 가능
        DefaultClass2 class2 = new DefaultClass2();       // ✅ 접근 가능
    }
}
```

- 같은 패키지이므로 public, default 클래스 모두 접근 가능

### ❌ 다른 패키지 접근: PublicClassOuterMain.java
```java
package access.b;

import access.a.PublicClass;
// import access.a.DefaultClass1; // ❌ 접근 불가

public class PublicClassOuterMain {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();     // ✅ 접근 가능
        // DefaultClass1 class1 = new DefaultClass1();   // ❌ 접근 불가
        // DefaultClass2 class2 = new DefaultClass2();   // ❌ 접근 불가
    }
}
```
- PublicClass는 public → 외부 패키지에서도 접근 가능
- DefaultClass1, DefaultClass2는 default → 외부 패키지에서는 접근 불가

## 🎯 핵심 요약
- 클래스 레벨에서는 `public`, `default`만 사용 가능
- `public` 클래스는 파일명과 클래스명이 반드시 같아야 함
- 하나의 자바 파일에 `public` 클래스는 하나만 존재 가능
- `default` 클래스는 같은 패키지에서만 접근 가능하며 여러 개 정의 가능
- 다른 패키지에서 `default` 클래스는 접근 불가


---


## 🔐 캡슐화란?
캡슐화(Encapsulation) 는 객체의 데이터(속성) 와 기능(메서드) 를 하나로 묶고,  
외부에서는 꼭 필요한 기능만 노출하고 나머지는 숨기는 객체 지향의 핵심 원칙입니다.

### 🎯 캡슐화의 목적

| 목적             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 데이터 보호       | 외부에서 직접 필드에 접근하지 못하게 막아, 잘못된 변경을 방지함         |
| 기능 제한         | 내부에서만 사용하는 기능은 숨겨서 사용자 혼란을 줄이고 안정성을 높임     |
| 복잡도 감소       | 꼭 필요한 기능만 노출하여 사용자가 객체를 쉽게 이해하고 사용할 수 있음   |
| 유지보수 용이     | 내부 구현을 자유롭게 변경해도 외부에 영향을 주지 않아 관리가 쉬움        |
| 무결성 보장       | 모든 데이터 변경이 검증된 메서드를 통해 이루어져 일관성과 안정성이 유지됨 |


### 🧩 예시: BankAccount 클래스
```java
public class BankAccount {
    private int balance; // 외부 접근 차단

    public BankAccount() {
        balance = 0;
    }

    public void deposit(int amount) {
        if (isAmountValid(amount)) {
            balance += amount;
        } else {
            System.out.println("유효하지 않은 금액입니다.");
        }
    }

    public void withdraw(int amount) {
        if (isAmountValid(amount) && balance - amount >= 0) {
            balance -= amount;
        } else {
            System.out.println("유효하지 않은 금액이거나 잔액이 부족합니다.");
        }
    }

    public int getBalance() {
        return balance;
    }

    private boolean isAmountValid(int amount) {
        return amount > 0;
    }
}
```

### ✅ 외부에서 사용할 수 있는 기능

| 메서드 이름     | 역할 설명                                  | 접근 제어자 |
|------------------|---------------------------------------------|--------------|
| deposit()        | 유효한 금액을 입금하고 잔고를 증가시킴       | public       |
| withdraw()       | 유효한 금액을 출금하고 잔고를 감소시킴       | public       |
| getBalance()     | 현재 잔고를 조회함                          | public       |

### ❌ 외부에서 숨겨야 할 기능

| 항목              | 역할 설명                                           | 접근 제어자 |
|-------------------|----------------------------------------------------|--------------|
| balance           | 잔고 데이터. 직접 수정 시 검증 로직을 무시하게 됨     | private       |
| isAmountValid()   | 입출금 금액 검증용 내부 로직. 외부 호출 시 혼란 초래 | private       |


### 🚗 비유로 이해하기
- 자동차 운전자는 핸들, 엑셀, 브레이크만 알면 됨
- 내부의 엔진, 배기 시스템, 전자 제어 장치는 숨겨져 있음
- 사용자는 필요한 기능만 사용하고, 내부는 안전하게 보호됨

### 📦 캡슐화 + 접근 제어자

| 접근 제어자 | 캡슐화에서의 역할                                      | 설명                                                             |
|-------------|--------------------------------------------------------|------------------------------------------------------------------|
| private     | 객체 내부로 숨김                                        | 외부 접근 완전 차단, 데이터 보호에 가장 적합                     |
| public      | 외부에 필요한 기능만 공개                               | 사용자에게 필요한 기능만 노출, 나머지는 숨김                     |
| default     | 패키지 내부로 숨김                                      | 같은 패키지에서만 접근 가능, 제한적 공개                         |
| protected   | 상속 관계에서만 공개                                    | 자식 클래스에게만 기능을 공유, 외부에는 숨김                     |


### ✅ 캡슐화의 효과
- 데이터 무결성 유지: 잘못된 값이 들어오는 것을 방지
- 사용자 혼란 방지: 꼭 필요한 기능만 보여주어 사용이 쉬움
- 유지보수 용이: 내부 구현 변경 시 외부 영향 최소화


---

## 🎯 캡슐화 문제 정리

### 전체 소스 코드
```java
public class ShoppingCart {

    private Item[] items = new Item[10];
    private int itemCount;

    public void addItem(Item item) {
        if (itemCount >= items.length) {
            System.out.println("장바구니가 가득 찼습니다.");
            return;
        }
        items[itemCount] = item;
        itemCount++;
    }

    public void displayItems() {
        System.out.println("장바구니 상품 출력");
        for (int i = 0; i < itemCount; i++) {
            Item item = items[i];
            System.out.println("상품명:" + item.getName() + ", 합계:" +
            item.getTotalPrice());
        }
        System.out.println("전체 가격 합:" + calculateTotalPrice());
    }

    private int calculateTotalPrice() {
        int totalPrice = 0;
        for (int i = 0; i < itemCount; i++) {
            Item item = items[i];
            totalPrice += item.getTotalPrice();
        }
        return totalPrice;
    }
}

```

### 1️⃣ MaxCounter 클래스
#### 📌 요구사항
- 최대값까지만 증가 가능한 카운터
- 외부에서 count 값을 직접 수정할 수 없어야 함
- 다른 패키지에서도 사용할 수 있어야 함


### ✅ 캡슐화 적용
| 구성 요소       | 접근 제어자 | 역할 설명                                      |
|----------------|--------------|------------------------------------------------|
| count          | private      | 외부에서 직접 수정 불가, 내부에서만 관리         |
| max            | private      | 최대값 설정용, 외부 접근 차단                    |
| increment()    | public       | 외부에서 호출 가능, 내부 로직으로 증가 제한 처리 |
| getCount()     | public       | 외부에서 현재 카운트 값 조회 가능               |


#### 💡 핵심 로직
```java
if (count >= max) {
    System.out.println("최대값을 초과할 수 없습니다.");
    return;
}
count++;
```


### 2️⃣ ShoppingCart & Item 클래스
#### 📌 요구사항
- 장바구니에 최대 10개 상품만 추가 가능
- 상품 정보는 외부에서 직접 수정 불가
- 다른 패키지에서도 사용할 수 있어야 함

### ✅ Item 클래스 캡슐화
| 구성 요소              | 접근 제어자 | 역할 설명                                      |
|------------------------|--------------|------------------------------------------------|
| name, price, quantity  | private      | 외부에서 직접 수정 불가, 객체 내부에서만 관리     |
| getName()              | public       | 상품명을 외부에서 조회할 수 있도록 공개           |
| getTotalPrice()        | public       | 가격 × 수량 계산 결과를 외부에 제공               |


### ✅ ShoppingCart 클래스 캡슐화
| 구성 요소              | 접근 제어자 | 역할 설명                                               |
|------------------------|--------------|----------------------------------------------------------|
| items[]                | private      | 상품 목록 배열. 외부에서 직접 접근 불가, 내부에서만 관리     |
| itemCount              | private      | 현재 담긴 상품 개수. 외부에서 직접 수정 불가               |
| addItem()              | public       | 외부에서 상품을 추가할 수 있는 기능. 최대 10개 제한 포함     |
| displayItems()         | public       | 장바구니에 담긴 상품 정보 출력 기능                        |
| calculateTotalPrice()  | private      | 전체 합계 계산용 내부 전용 메서드. 외부에서는 호출 불가      |


### 💡 핵심 로직
```java
if (itemCount >= items.length) {
    System.out.println("장바구니가 가득 찼습니다.");
    return;
}
```


### 📦 캡슐화의 효과

| 효과             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 데이터 보호       | `private` 필드를 통해 외부의 직접 수정 차단 → 무결성 유지              |
| 기능 제한         | `private` 메서드를 통해 내부 전용 기능 숨김 → 사용자 혼란 방지           |
| 사용 편의성       | `public` 메서드만 노출 → 필요한 기능만 제공되어 사용이 쉬움              |
| 유지보수 용이     | 내부 구현 변경 시 외부 영향 없음 → 안정적인 코드 관리 가능               |
| 객체 책임 분리    | 객체가 스스로 데이터를 관리하고 검증 → 외부는 결과만 신뢰하면 됨         |

---

