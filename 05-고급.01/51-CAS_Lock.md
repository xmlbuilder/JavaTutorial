# 🔒 CAS 기반 락 구현 - 핵심 개념
## ✅ 목표
- synchronized나 ReentrantLock 없이 **CAS(Compare-And-Swap)** 를 활용해 **스핀 락(spin lock)** 을 구현

## ❌ 잘못된 락 구현 (SpinLockBad)
### 🔧 문제 코드
```java
if (!lock) {
    sleep(100); // 스레드 동시 실행 유도
    lock = true;
    break;
}
```

### ⚠️ 문제점
- lock 사용 여부 확인과 `lock = true` 설정이 원자적이지 않음
- 두 스레드가 동시에 `lock == false` 를 확인하고 동시에 `lock = true` 실행 → 동시 락 획득
- 결과적으로 임계 영역이 보호되지 않음

## ✅ CAS로 해결하는 방식
### 🔧 핵심 아이디어
- `lock == false` 일 때만 true로 바꾸는 연산을 원자적으로 처리
- CAS 연산은 바로 이 구조에 적합:
```java
while (!atomic.compareAndSet(false, true)) {
    // 실패 시 스핀 대기
}
```
- compareAndSet(expected, update)는 현재 값이 expected와 같을 때만 update로 변경

## 🔁 CAS 기반 스핀 락 흐름
```java
public void lock() {
    log("락 획득 시도");
    while (!atomicLock.compareAndSet(false, true)) {
        log("락 획득 실패 - 스핀 대기");
    }
    log("락 획득 완료");
}
```
```java
public void unlock() {
    atomicLock.set(false);
    log("락 반납 완료");
}
```
- atomicLock은 AtomicBoolean으로 선언
- 락 획득 실패 시 루프 반복 (스핀 대기)
- 락 반납은 단순한 `set(false)` → 원자적이므로 안전

## 📊 CAS 락 vs 잘못된 락 비교

| 항목               | SpinLockBad                         | AtomicBoolean (CAS 기반 락)         |
|--------------------|--------------------------------------|--------------------------------------|
| 락 획득 방식        | `if (!lock) → lock = true`           | `compareAndSet(false, true)`         |
| 원자성 보장         | ❌ 없음 (두 연산 분리됨)              | ✅ 있음 (CPU 명령어로 원자적 처리)    |
| 동시 접근 안전성     | ❌ 충돌 발생 가능                     | ✅ 충돌 시 재시도                     |
| 스레드 충돌 시 처리 | 스레드 모두 락 획득 가능             | 실패한 스레드는 루프 반복 (스핀 대기) |
| 락 반납 방식        | `lock = false`                       | `atomic.set(false)`                  |
| 실무 적합성         | ⚠️ 위험함, 동시성 문제 발생 가능       | ✅ 안전하고 실무에 적합                |

## 🧠 핵심 요약
- SpinLockBad는 락 획득 과정이 원자적이지 않아 두 스레드가 동시에 락을 획득하는 문제가 발생
- AtomicBoolean을 활용한 CAS 기반 락은 값 비교 + 교체를 하나의 원자적 연산으로 처리하므로 안전함
- CAS 기반 락은 낙관적 접근 방식으로, 충돌이 적은 환경에서 특히 효과적


## 🧠 결론 요약
- CAS는 값 비교 + 교체를 하나의 원자적 연산으로 처리
- 락 구현 시 compareAndSet()을 활용하면 락 사용 여부 확인 + 설정을 동시에 처리 가능
- 스핀 락은 간단한 임계 영역에서만 사용해야 하며, 오래 걸리는 작업에는 부적합
- CAS 기반 락은 낙관적 접근 방식으로, 충돌이 적은 환경에서 매우 효과적

---

# 🔒 CAS 락 구현 요약
## ✅ 핵심 개념
- CAS(Compare-And-Swap)를 활용해 `AtomicBoolean` 으로 락을 구현
- compareAndSet(false, true)를 통해 락 사용 여부 확인 + 락 설정을 원자적으로 처리
- 실패 시 while 루프를 반복하며 스핀 대기(busy-wait) 방식으로 락을 획득

## 🧪 CAS 락 동작 흐름
```java
while (!lock.compareAndSet(false, true)) {
    // 락 획득 실패 → 스핀 대기
}
```
- false일 때만 true로 바꾸는 연산을 CPU가 원자적으로 처리
- 락 반납은 `lock.set(false)` 로 간단하게 처리

## 🔁 스핀 락 특징

| 항목             | 설명                                      |
|------------------|-------------------------------------------|
| 대기 방식         | 반복 루프를 돌며 락 상태를 계속 확인       |
| 스레드 상태       | `RUNNABLE` 상태 유지 (CPU 계속 사용)       |
| 장점             | 빠른 락 획득, 상태 전환 없음               |
| 단점             | 충돌 시 CPU 자원 과다 사용 가능             |
| 적합한 상황       | 아주 짧은 연산 (예: 카운터 증가, 리스트 삽입) |
| 부적합한 상황     | 오래 걸리는 작업 (예: DB, 네트워크 대기 등)  |

## 🧠 핵심 요약
- 스핀 락은 빠른 락 획득이 필요한 짧은 연산에 적합
- CPU를 계속 사용하기 때문에 충돌이 많거나 연산이 길면 비효율적
- 실무에서는 `AtomicBoolean`, `AtomicInteger` 등으로 간단한 락을 구현할 때 사용


## ⚖️ CAS vs 동기화 락 비교

| 항목               | CAS 방식 (AtomicBoolean 등)       | 동기화 락 방식 (`synchronized` / `Lock`) |
|--------------------|-----------------------------------|-------------------------------------------|
| 접근 전략          | 낙관적 (충돌 없다고 가정)          | 비관적 (충돌 있다고 가정)                 |
| 충돌 처리 방식      | 실패 시 루프 반복 (스핀 대기)       | 대기 상태로 전환 (`BLOCKED` / `WAITING`) |
| 스레드 상태         | `RUNNABLE` 상태 유지               | `BLOCKED` 또는 `WAITING`으로 전환         |
| 성능               | 충돌 적으면 매우 빠름              | 안정적이지만 컨텍스트 스위칭 오버헤드 있음 |
| CPU 자원 사용       | 충돌 시 반복 → 자원 소모 많음       | 대기 중 자원 거의 사용 안 함              |
| 적합한 작업         | 짧은 연산 (예: 카운터 증가 등)      | 긴 연산, 외부 자원 대기 포함 작업          |
| 안정성             | 충돌 많으면 성능 저하 가능          | 충돌 많아도 안정적으로 처리 가능          |

## 🧠 핵심 요약
- CAS 방식은 빠르고 가볍지만, 충돌이 많거나 연산이 길면 오히려 비효율적
- 동기화 락 방식은 안정적이고 충돌 관리에 강하지만, 성능 오버헤드가 존재
- 실무에서는 연산의 특성과 충돌 빈도에 따라 적절한 동기화 전략 선택이 중요


## 🧠 실무 적용 전략
- 대부분의 실무 환경에서는 충돌이 드물기 때문에 CAS 방식이 더 효율적
- 예: 주문 수 증가, 실시간 카운터, 메모리 내 자료 구조 수정 등
- 단, **외부 자원 대기(DB, 네트워크 등)** 가 포함된 작업에는 동기화 락이 더 적합
- 자바의 동시성 라이브러리(AtomicInteger, ConcurrentHashMap)는 내부적으로 CAS를 적극 활용

## ✅ 결론 요약 - CAS 락 구현

| 항목               | 설명 요약                                       |
|--------------------|--------------------------------------------------|
| 구현 방식           | `compareAndSet(false, true)`으로 원자적 락 획득  |
| 대기 방식           | 스핀 대기 (`while` 루프 반복)                   |
| 스레드 상태         | `RUNNABLE` 상태 유지, CPU 계속 사용              |
| 적합한 상황         | 짧은 연산, 충돌 적은 환경                        |
| 부적합한 상황       | 긴 연산, 외부 자원 대기 (DB, 네트워크 등)        |
| 실무 활용 전략      | 직접 구현보다는 CAS 기반 라이브러리 활용         |

---

