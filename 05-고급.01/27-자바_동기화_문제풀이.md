# 🔍 자바 동기화 문제풀이 & 정리

## 🧠 문제 1: 공유 자원 동기화

### 📌 문제 설명
- 두 스레드가 Counter 객체의 increment()를 각각 10,000번 호출 → 기대 결과는 count = 20000

### ❌ 잘못된 코드
```java
static class Counter {
    private int count = 0;
    public void increment() {
        count = count + 1;
    }
    public int getCount() {
        return count;
    }
}
```

### ⚠️ 문제점
- count = count + 1은 3단계 작업:
- count 읽기
- 1 더하기
- 다시 저장
- 두 스레드가 동시에 접근하면 경합 조건(Race Condition) 발생 → 값 손실

### ✅ 해결 코드
```java
static class Counter {
    private int count = 0;
    public synchronized void increment() {
        count = count + 1;
    }
    public synchronized int getCount() {
        return count;
    }
}
```

### 🔐 핵심 포인트
- synchronized로 임계 영역 보호
- 한 번에 하나의 스레드만 increment() 실행 가능
- 정확한 결과 보장: 결과: 20000

## 🧠 문제 2: 지역 변수의 동시성
### 📌 문제 설명
- 두 스레드가 MyCounter.count()를 동시에 실행 → localValue는 동기화 필요할까?

#### 코드 예시
```java
static class MyCounter {
    public void count() {
        int localValue = 0;
        for (int i = 0; i < 1000; i++) {
            localValue = localValue + 1;
        }
        log("결과: " + localValue);
    }
}
```

#### ✅ 정답
- localValue는 지역 변수
- 각 스레드의 스택 메모리에 저장됨 → 절대 공유되지 않음
- 동기화 필요 없음, synchronized 사용하면 오히려 성능 저하

## 🧠 문제 3: final 필드의 안전성

### 📌 문제 설명
- Immutable.value는 공유 자원이다. 멀티스레드에서 문제가 될까?

#### 코드 예시
```java
class Immutable {
    private final int value;
    public Immutable(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
}
```

#### ✅ 정답
- value는 final → 초기화 이후 변경 불가
- 여러 스레드가 접근해도 읽기만 가능 → 동기화 필요 없음
- **불변 객체(Immutable Object)** 는 멀티스레드 환경에서 안전

## 🧾 종합 정리
### 🔒 synchronized 장점
- 자바 문법으로 제공 → 사용 간편
- 자동 잠금 해제 → 개발자 관리 부담 ↓

### ⚠️ synchronized 단점

| 문제       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 무한 대기   | 락을 얻을 때까지 BLOCKED 상태로 대기하며, 타임아웃 설정이 불가능함     |
| 인터럽트 불가 | 대기 중인 스레드를 중간에 강제로 깨울 수 없음                         |
| 공정성 부족 | 어떤 스레드가 락을 얻을지 예측 불가. 특정 스레드가 계속 기다릴 수 있음 |
| 성능 저하   | 과도한 동기화는 병렬 처리 성능을 떨어뜨림                              |
| 단순 제어   | 세밀한 락 제어가 어려움. 고급 기능은 `java.util.concurrent`가 필요함   |

### 💡 해결책
- 자바 1.5부터 java.util.concurrent 패키지 도입
- 더 세밀한 제어 가능 (예: ReentrantLock, AtomicInteger, Semaphore 등)

## 🎯 핵심 요약

| 항목                  | 설명                                                                 |
|-----------------------|----------------------------------------------------------------------|
| 공유 자원             | 여러 스레드가 접근 가능. 변경 가능성이 있으면 반드시 동기화 필요       |
| synchronized          | 자바 문법으로 제공되는 기본 동기화 방식. 사용 간편하지만 제어는 제한적 |
| 지역 변수             | 스레드마다 독립된 스택에 저장됨. 동기화 불필요                        |
| final 필드            | 불변 객체로 변경 불가. 멀티스레드 환경에서도 안전                     |
| java.util.concurrent  | 고급 동기화 도구 제공. 더 유연하고 세밀한 제어 가능                    |


---

