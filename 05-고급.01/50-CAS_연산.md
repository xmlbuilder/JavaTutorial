# CAS 연산
아래는 CAS 연산을 활용한 incrementAndGet() 구현 방식에 대한 핵심 원리, 코드 흐름, 성공/실패 시 동작,  
그리고 멀티스레드 환경에서의 의미를 정리한 내용입니다.

## 🔧 CAS 연산으로 value++ 구현하기

### ✅ 문제 배경
- value++는 내부적으로 다음과 같은 비원자적 연산입니다:
```java
i = i + 1;
```
- 이 연산은 3단계로 나뉘며, 중간에 다른 스레드가 i를 변경할 수 있어 **경합(race condition)** 이 발생합니다.

## 🔒 CAS 기반 incrementAndGet() 구현
### 🔁 핵심 로직
```java
do {
    getValue = atomicInteger.get(); // 현재 값 읽기
    result = atomicInteger.compareAndSet(getValue, getValue + 1); // CAS 시도
} while (!result); // 실패 시 재시도
return getValue + 1;
```
- compareAndSet()은 내부적으로 CAS 연산을 수행
- 현재 값이 기대한 값과 같으면 → 새 값으로 교체 → true 반환
- 값이 바뀌었으면 → 실패 → false 반환 → 다시 시도

🧪 실행 흐름 요약
▶ 단일 스레드 실행 시
start value = 0
getValue: 0 → CAS 성공 → value = 1
getValue: 1 → CAS 성공 → value = 2
- CAS는 항상 성공 → do-while 루프는 한 번만 실행됨

▶ 멀티스레드 환경에서
- 여러 스레드가 동시에 get() → 같은 값을 읽음
- 첫 번째 스레드가 CAS 성공 → 값 변경
- 나머지 스레드는 CAS 실패 → 루프 반복 → 재시도
- 이 방식은 락 없이도 안전하게 값을 증가시킬 수 있는 대표적인 락 프리 알고리즘입니다.


## 📘 핵심 요약 - CAS 기반 증가 연산

| 연산 방식     | 설명                         | 특징 요약                     |
|---------------|------------------------------|-------------------------------|
| `value++`     | 비원자적 연산                | 경합 발생 가능, 안전하지 않음 |
| `compareAndSet()` | 기대값과 현재값 비교 후 교체 | CPU가 제공하는 원자적 연산     |
| `do-while`    | 실패 시 재시도 루프          | 락 없이 안전하게 반복 처리     |

## 🧠 핵심 포인트
- value++는 내부적으로 여러 단계로 나뉘기 때문에 멀티스레드 환경에서 안전하지 않음
- compareAndSet()은 CAS 연산을 통해 원자적으로 값 교체
- do-while 루프를 사용하면 CAS 실패 시 자동으로 재시도하여 락 없이 안전한 증가 연산 구현 가능


## 🧠 결론
- CAS는 단일 값 교체만 가능하지만, 재시도 루프를 통해 복잡한 연산도 안전하게 처리 가능
- AtomicInteger.incrementAndGet()은 내부적으로 이 방식으로 구현되어 있음
- 멀티스레드 환경에서도 경합 없이 안전하고 빠르게 값 증가 가능

---

# 🔧 CAS 연산 실패 처리 - 핵심 개념

## ✅ 목적
- 멀티스레드 환경에서 CAS 연산이 실패하는 상황을 실험
- 실패 후 재시도 루프를 통해 값이 정상적으로 증가되는지 확인

## 🧪 코드 흐름 요약
```java
do {
    getValue = atomicInteger.get();         // 현재 값 읽기
    sleep(100);                             // 스레드 동시 실행 유도
    result = atomicInteger.compareAndSet(getValue, getValue + 1); // CAS 시도
} while (!result);                          // 실패 시 재시도
```
- 두 스레드가 동시에 get() → 같은 값(0)을 읽음
- 한 스레드가 먼저 compareAndSet() 성공 → 값 변경
- 다른 스레드는 CAS 실패 → 루프 반복 → 다시 시도 → 성공

## 📊 실행 결과 분석 - CAS 연산 실패 및 재시도 흐름

| 스레드 이름 | getValue 호출 시 값 | CAS 시도 값 (expected → new) | CAS 결과 | 최종 반영 여부 |
|-------------|----------------------|-------------------------------|-----------|----------------|
| Thread-1    | 0                    | 0 → 1                         | ✅ 성공    | 값 1로 변경     |
| Thread-0    | 0                    | 0 → 1                         | ❌ 실패    | 변경 안됨       |
| Thread-0    | 1                    | 1 → 2                         | ✅ 성공    | 값 2로 변경     |
- 🔁 CAS 실패 시 do-while 루프를 통해 재시도하여 결국 값 증가 성공


## 🔒 CAS vs Lock 방식 비교

| 항목               | CAS 방식 (낙관적 접근)                  | Lock 방식 (비관적 접근)               | 설명 요약                                  |
|--------------------|------------------------------------------|----------------------------------------|---------------------------------------------|
| 접근 전략          | 충돌 없다고 가정, 실패 시 재시도         | 충돌 있다고 가정, 먼저 락 획득         | 충돌 발생 가능성에 대한 접근 방식 차이       |
| 동시성 처리        | 락 없이 바로 접근, 실패 시 루프 반복     | 락 획득 후 임계 영역 진입               | CAS는 병렬성 높고, Lock은 순차적 처리        |
| 성능               | 🚀 빠름 (충돌 적을 때 매우 효율적)        | 🐢 느림 (모든 스레드가 대기)            | CAS는 락 오버헤드 없음                       |
| 충돌 시 처리 방식  | 재시도 루프 (`do-while`)                | 대기 후 순서대로 처리                   | CAS는 실패 시 반복, Lock은 대기              |
| CPU 자원 사용      | 충돌 많으면 반복으로 자원 소모           | 컨텍스트 스위칭, 대기 시간 발생         | 충돌 많을 경우 CAS는 오히려 비효율적일 수 있음 |
| 적용 대상          | 간단한 연산, 충돌 적은 환경에 적합       | 복잡한 연산, 충돌 많은 환경에 적합      | 상황에 따라 선택 필요                        |

### 🧠 핵심 요약
- CAS는 락 없이도 원자적 연산을 수행할 수 있는 고성능 기법이며, 충돌이 적은 환경에서 특히 효과적입니다.
- Lock은 모든 스레드가 순서대로 자원에 접근하므로 안정적이지만 성능 오버헤드가 큽니다.
- 실무에서는 연산의 복잡도와 충돌 빈도에 따라 CAS 또는 Lock을 선택하는 것이 중요합니다.

## 🧠 언제 CAS를 사용하면 좋을까?
- 충돌이 적은 환경에서 CAS는 락보다 훨씬 빠름
- 예: value++ 같은 단순한 연산은 CPU가 너무 빠르게 처리하므로 충돌이 거의 없음
- 실험 결과:
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```
- MyAtomicInteger는 CAS 기반 → 락 없이도 정확한 결과
- BasicInteger는 충돌로 인해 일부 연산 손실

## ✅ 결론 요약 - CAS 연산 구조와 특징

| 항목           | 핵심 개념           | 설명 요약                                 |
|----------------|---------------------|--------------------------------------------|
| CAS 구조       | `compareAndSet()`   | 기대값과 현재값 비교 후 일치하면 교체       |
| 실패 처리 방식 | `do-while` 루프     | 실패 시 재시도하여 결국 성공               |
| 접근 전략      | 낙관적 접근 방식     | 충돌 없다고 가정하고 바로 접근              |
| 성능 특징      | 락 프리 구조         | 충돌 적은 환경에서 락보다 빠름              |
| 적용 대상      | 단순 연산에 적합     | `value++`, 카운터, 플래그 등 간단한 공유값 |

## 🧠 핵심 포인트
- CAS는 CPU가 제공하는 원자적 명령어로 락 없이도 안전한 연산을 수행
- 실패 시 do-while 루프를 통해 재시도 → 결국 값 변경 성공
- 충돌이 적은 환경에서는 락보다 훨씬 빠르고 효율적

