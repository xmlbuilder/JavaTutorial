# 메모리 가시화 최종 정리

## 🔍 메모리 가시성 문제: 단계별 이해
### 1️⃣ 문제 상황: volatile 미적용

#### 코드
```java
public class VolatileCountMain {
    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread t = new Thread(task, "work");
        t.start();

        sleep(1000);

        task.flag = false;
        log("flag = " + task.flag + ", count = " + task.count + " in main");
    }

    static class MyTask implements Runnable {
        boolean flag = true;
        long count;
        //volatile boolean flag = true;
        //volatile long count;
        
        @Override
        public void run() {
            while (flag) {
                count++;
                //1억번에 한번씩 출력
                if (count % 100_000_000 == 0) {
                    //주석 처리 한다면...
                    log("flag = " + flag + ", count = " + count + " in while()");
                }
            }
            log("flag = " + flag + ", count = " + count + " 종료");
        }
    }
}
```

#### 💡 코드 요약
- flag가 true일 때 work 스레드는 count++ 반복
- main 스레드는 1초 후 flag = false로 변경
- work 스레드는 flag가 false가 될 때 루프 탈출

#### ⚠️ 실행 결과
```
[ main] flag = false, count = 1176711196 in main
[ work] flag = true, count = 1200000000 in while()
[ work] flag = false, count = 1200000000 종료
```

#### 📌 문제 분석
- main 스레드가 flag = false로 변경했지만,
- work 스레드는 **캐시 메모리의 flag = true** 를 계속 참조
- flag 변경을 즉시 인식하지 못함
- 루프 탈출까지 수백 밀리초 지연 발생

### 2️⃣ 원인: CPU 캐시와 메모리 불일치

| 항목               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 메인 메모리         | 모든 스레드가 공유하는 공간. 변수의 실제 값이 저장됨                   |
| CPU 캐시 메모리     | 각 코어가 독립적으로 사용하는 고속 메모리. 성능 향상을 위해 사용됨       |
| 캐시 불일치 현상     | 한 스레드가 값을 변경해도 다른 스레드의 캐시에는 즉시 반영되지 않음       |
| 가시성 지연         | 변경된 값이 다른 스레드에 보이기까지 시간이 지연될 수 있음               |

### 3️⃣ 해결 방법: volatile 적용
#### ✅ 코드 변경
```java
volatile boolean flag = true;
volatile long count;
```

#### ✅ 실행 결과
```
[ work] flag = false, count = 222297705 종료
[ main] flag = false, count = 222297705 in main
```

#### 📌 효과
- main 스레드가 flag = false로 변경하자마자
- work 스레드가 즉시 변경을 감지하고 루프 탈출
- 메모리 가시성 확보 성공

#### 4️⃣ 성능 비교

| 항목               | volatile 미적용                          | volatile 적용                              |
|--------------------|-------------------------------------------|---------------------------------------------|
| 루프 탈출 시점의 count | 약 1,176,711,196                          | 약 222,297,705                               |
| 반응 속도           | 느림 (캐시 갱신 시까지 대기)              | 빠름 (변경 즉시 감지)                        |
| 메모리 접근 방식     | 캐시 메모리 → 메인 메모리 불일치 가능성 있음 | 항상 메인 메모리 직접 접근                   |
| 실행 시간           | 길어짐 (불필요한 반복 지속)               | 짧아짐 (빠른 종료)                           |
| 성능 영향           | 빠름 (캐시 사용으로 연산 속도 높음)        | 느림 (캐시 우회로 연산 속도 저하 가능성 있음) |


## 🎯 핵심 요약

| 항목             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| 멀티스레드 문제   | 스레드 간 메모리 불일치로 인해 값 변경이 즉시 반영되지 않을 수 있음     |
| 메모리 가시성     | 한 스레드의 변경이 다른 스레드에서 언제 보이는지를 의미함               |
| volatile          | 메인 메모리에 직접 접근하여 가시성 문제를 해결함                       |
| 캐시 무시         | volatile 변수는 CPU 캐시를 사용하지 않고 항상 최신 값을 읽음            |
| 성능 영향         | 캐시를 우회하므로 성능이 저하될 수 있어 꼭 필요한 곳에만 사용해야 함     |
| 원자성 보장 여부   | volatile은 원자성을 보장하지 않음 → 복합 연산에는 synchronized 또는 Atomic 필요 |

---
