# 🔬 원자적 연산이란?
**원자적 연산(Atomic Operation)** 은 더 이상 나눌 수 없는 단일 단위의 연산을 의미합니다.  
즉, 해당 연산은 중단 없이, 다른 스레드의 간섭 없이, 완전히 실행되거나 전혀 실행되지 않는 성질을 가집니다.  
💡 이름의 유래: 과거 물리학에서 원자는 더 이상 나눌 수 없는 가장 작은 단위로 여겨졌기 때문에,  
이 개념을 컴퓨터 과학에서도 그대로 차용했습니다.  


## 🧠 원자적 연산의 특징
- 불가분성: 연산이 중간에 끊기거나 나뉘지 않음
- 동시성 안전성: 여러 스레드가 동시에 접근해도 값이 손상되지 않음
- 중간 상태 없음: 연산 중간에 다른 스레드가 관여할 수 없음

## 🔍 예시로 보는 원자성과 비원자성
### ✅ 원자적 연산 예시
i = 1;
- 단일 대입 연산
- 중간 단계 없이 바로 i에 1이 들어감

### ❌ 비원자적 연산 예시
i = i + 1;
- 내부적으로 3단계로 나뉨:
- i 값을 읽음
- 1을 더함
- 결과를 다시 i에 저장
이 과정에서 다른 스레드가 i를 수정하면 **경합(race condition)** 이 발생할 수 있음


## 🧵 멀티스레드 상황에서의 문제
### ▶ 순차 실행 시
```
초기값: i = 0
스레드1 → i = i + 1 → i = 1
스레드2 → i = i + 1 → i = 2
```
- 결과: 정상적으로 i = 2
### ▶ 동시 실행 시
```
초기값: i = 0
스레드1 → 읽기: i = 0 → 더하기: 1 → 저장: i = 1
스레드2 → 읽기: i = 0 → 더하기: 1 → 저장: i = 1
```
- 결과: i = 1 → 한 번의 증가가 사라짐  
❗ 이 현상을 lost update 또는 race condition이라고 부릅니다


## ❓ i++는 원자적일까?
아니요. i++는 사실 i = i + 1의 축약형이며, 내부적으로 동일한 3단계 연산을 수행합니다.  
따라서 원자적이지 않으며, 멀티스레드 환경에서는 안전하지 않습니다.  

## 🧪 실전 코드 예제: 원자적이지 않은 증가 연산
### 🔧 인터페이스 정의
```java
public interface IncrementInteger {
    void increment();
    int get();
}
```

### 🔧 기본 구현 (비원자적)
```java
public class BasicInteger implements IncrementInteger {
    private int value;

    @Override
    public void increment() {
        value++; // 비원자적 연산
    }

    @Override
    public int get() {
        return value;
    }
}
```

### 🔧 테스트 코드
```java
public static final int THREAD_COUNT = 1000;

public static void main(String[] args) throws InterruptedException {
    IncrementInteger counter = new BasicInteger();
    List<Thread> threads = new ArrayList<>();

    Runnable task = () -> {
        sleep(10); // 동시성 유도
        counter.increment();
    };

    for (int i = 0; i < THREAD_COUNT; i++) {
        Thread t = new Thread(task);
        threads.add(t);
        t.start();
    }

    for (Thread t : threads) {
        t.join();
    }

    System.out.println("결과: " + counter.get());
}
```

### 🧾 실행 결과
```
BasicInteger result: 950
```
- 기대값: 1000
- 실제값: 950 (환경에 따라 다름)
- 이유: 여러 스레드가 동시에 value++를 수행하면서 경합 발생

### ❓ volatile로 해결될까?
아쉽게도 아님. volatile은 **가시성(visibility)**만 보장하며, **원자성(atomicity)** 은 보장하지 않습니다.
- volatile은 변수의 최신 값을 모든 스레드가 볼 수 있도록 보장
- 하지만 value++는 여전히 3단계로 나뉘기 때문에 경합을 막지 못함
- 원자성을 보장하려면 `synchronized`, `Lock`, 또는 `AtomicInteger` 같은 원자적 클래스를 사용해야 합니다

## ✅ 결론 - 원자적 연산과 멀티스레드 안전성

| 연산 방식     | 내부 동작         | 멀티스레드 안전성                        |
|--------------|------------------|------------------------------------------|
| `i++`        | `i = i + 1`      | ❌ 원자적이지 않음                       |
| `volatile`   | 가시성만 보장     | ❌ 원자성은 보장하지 않음                |
| 안전한 방식  | `synchronized`, `Lock`, `AtomicInteger` | ✅ 원자성 보장, 멀티스레드 환경에서 안전 |

## 🧠 요약
- i++은 내부적으로 i = i + 1과 동일 → 비원자적
- volatile은 값의 최신 상태 공유만 보장 → 연산 자체의 안전성은 없음
- synchronized, Lock, AtomicInteger는 원자성 보장 → 멀티스레드 환경에서 안전

---


## 🔒 원자적 연산 - volatile vs synchronized
멀티스레드 환경에서 공유 자원을 안전하게 다루기 위해서는 **원자성(atomicity)** 이 보장되어야 합니다.  
하지만 i++ 같은 연산은 내부적으로 여러 단계로 나뉘기 때문에 원자적이지 않으며, 경합 조건(race condition)이 발생할 수 있습니다.

## 🧪 예제 1: volatile 사용
```java
public class VolatileInteger implements IncrementInteger {
    private volatile int value;

    @Override
    public void increment() {
        value++; // 비원자적 연산
    }

    @Override
    public int get() {
        return value;
    }
}
```

## 🔍 결과
```
BasicInteger result: 950
VolatileInteger result: 961
```

## ❗ 분석
- volatile은 **가시성(visibility)** 만 보장합니다.
- 즉, 여러 CPU 캐시 간의 동기화는 되지만, value++는 여전히 3단계 연산이므로 원자성은 보장되지 않음
- 따라서 여전히 값 손실이 발생할 수 있음

## 🧪 예제 2: synchronized 사용
```java
public class SyncInteger implements IncrementInteger {
    private int value;

    @Override
    public synchronized void increment() {
        value++; // 임계 영역 내에서 안전하게 수행
    }

    @Override
    public synchronized int get() {
        return value;
    }
}
```

## ✅ 결과
```
SyncInteger result: 1000
```

## ✅ 분석
- synchronized는 **임계 영역(critical section)** 을 만들어 한 번에 하나의 스레드만 접근 가능하게 함
- value++ 연산 전체가 원자적으로 보호되므로 정확한 결과 보장

## 📘 결론 요약 - 원자적 연산과 멀티스레드 안전성

| 방식           | 원자성 보장 | 가시성 보장 | 동시성 안전성 | 설명                                      |
|----------------|-------------|-------------|----------------|-------------------------------------------|
| `volatile`     | ❌          | ✅          | ❌             | 캐시 동기화는 되지만 연산 자체는 나뉨     |
| `synchronized` | ✅          | ✅          | ✅             | 연산 전체를 임계 영역으로 보호            |


## 🧠 핵심 요약
- volatile은 값의 최신 상태 공유만 보장하며, 연산 자체의 원자성은 보장하지 않음
- synchronized는 임계 영역을 통해 연산 전체를 보호하여 멀티스레드 환경에서도 안전하게 동작

---

# 원자적 연산 - AtomicInteger
자바는 멀티스레드 환경에서 안전한 정수 연산을 위해 AtomicInteger 클래스를 제공합니다.  
이 클래스는 이름 그대로 원자적인 Integer 연산을 제공하며, 락 없이도 동시성 안전성을 확보할 수 있습니다.

## 🧪 예제: MyAtomicInteger
```java
public class MyAtomicInteger implements IncrementInteger {
    AtomicInteger atomicInteger = new AtomicInteger(0);

    @Override
    public void increment() {
        atomicInteger.incrementAndGet(); // 원자적 증가
    }

    @Override
    public int get() {
        return atomicInteger.get(); // 현재 값 조회
    }
}
```
- new AtomicInteger(0) : 초기값 설정
- incrementAndGet() : 값을 하나 증가하고 결과 반환
- get() : 현재 값 반환

## 🧵 멀티스레드 테스트 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```

- AtomicInteger는 SyncInteger와 동일하게 정확한 결과를 보장
- 하지만 락 없이 원자성을 확보하므로 성능이 더 우수

## 🚀 성능 테스트 결과 (COUNT = 100,000,000)
```
BasicInteger: ms=39
VolatileInteger: ms=455
SyncInteger: ms=625
MyAtomicInteger: ms=367
```

## 📘 원자적 연산 클래스 비교 요약

| 클래스            | 원자성 보장 | 가시성 보장 | 멀티스레드 안전성 | 성능 (COUNT=100M 기준) |
|-------------------|-------------|-------------|--------------------|------------------------|
| `BasicInteger`     | ❌          | ❌          | ❌                 | 🔥 매우 빠름 (39ms)     |
| `VolatileInteger`  | ❌          | ✅          | ❌                 | ⚡ 빠름 (455ms)         |
| `SyncInteger`      | ✅          | ✅          | ✅                 | 🐢 느림 (625ms)         |
| `MyAtomicInteger`  | ✅          | ✅          | ✅                 | 🚀 우수 (367ms)         |

## 🧠 핵심 요약
- BasicInteger: 단일 스레드에서만 사용 가능, 가장 빠름
- VolatileInteger: 가시성은 보장되지만 연산은 원자적이지 않음
- SyncInteger: synchronized로 원자성 확보, 성능은 낮음
- MyAtomicInteger: 락 없이 원자성 확보, 성능과 안전성 모두 우수

## 📘 결론 요약 - 원자적 연산 클래스 비교

| 클래스            | 원자성 보장 | 가시성 보장 | 멀티스레드 안전성 | 락 사용 여부 | 성능 (100M 기준) | 특징 요약                          |
|-------------------|-------------|-------------|--------------------|---------------|------------------|-----------------------------------|
| BasicInteger      | ❌          | ❌          | ❌                 | ❌            | 🔥 매우 빠름 (39ms) | 단일 스레드 전용, 캐시 활용        |
| VolatileInteger   | ❌          | ✅          | ❌                 | ❌            | ⚡ 빠름 (455ms)     | 가시성만 보장, 연산은 비원자적     |
| SyncInteger       | ✅          | ✅          | ✅                 | ✅            | 🐢 느림 (625ms)     | 락 기반 임계 영역, 안전하지만 느림 |
| AtomicInteger     | ✅          | ✅          | ✅                 | ❌            | 🚀 우수 (367ms)     | CAS 기반, 락 없이 빠르고 안전함   |

## 🧠 핵심 요약
- BasicInteger: 가장 빠르지만 멀티스레드 환경에서는 위험
- VolatileInteger: 가시성은 확보되지만 원자성은 없음
- SyncInteger: 안전하지만 락으로 인해 성능 저하
- AtomicInteger: 락 없이 원자성 확보, 성능과 안정성 모두 우수


## 🧠 결론
- AtomicInteger는 락 없이도 원자적 연산을 보장하는 고성능 동시성 도구입니다.
- 내부적으로 CAS(Compare-And-Swap) 기반으로 동작하여, synchronized보다 빠르고 안전합니다.
- 자바는 AtomicLong, AtomicBoolean, AtomicReference 등 다양한 원자적 클래스도 함께 제공합니다.

--- 

# AtomicInteger 함수 목록

아래는 자바의 AtomicInteger를 기반으로 만든 MyAtomicInteger 클래스에서 자주 사용하는 중요한 함수 목록과 함께,  
각 함수의 설명과 샘플 코드를 Markdown 표로 정리한 내용.

## 📘 MyAtomicInteger 주요 함수 요약표
| 메서드 이름           | 설명                                      | 반환값 / 효과             | 샘플 코드 예시                          |
|------------------------|-------------------------------------------|----------------------------|------------------------------------------|
| `get()`                | 현재 값을 조회                            | 현재 값 (`int`)           | `int value = atomicInteger.get();`       |
| `set(int newValue)`    | 값을 지정한 값으로 설정                   | void                      | `atomicInteger.set(100);`                |
| `incrementAndGet()`    | 값을 1 증가시키고 증가된 값을 반환        | 증가된 값 (`int`)         | `int result = atomicInteger.incrementAndGet();` |
| `getAndIncrement()`    | 값을 1 증가시키고 이전 값을 반환          | 이전 값 (`int`)           | `int result = atomicInteger.getAndIncrement();` |
| `addAndGet(int delta)` | 지정한 값만큼 증가시키고 결과 반환        | 증가된 값 (`int`)         | `int result = atomicInteger.addAndGet(5);` |
| `getAndAdd(int delta)` | 지정한 값만큼 증가시키고 이전 값 반환     | 이전 값 (`int`)           | `int result = atomicInteger.getAndAdd(5);` |
| `compareAndSet(expect, update)` | 현재 값이 기대값과 같으면 새 값으로 변경 | 성공 여부 (`boolean`)     | `boolean updated = atomicInteger.compareAndSet(10, 20);` |



## 🧪 샘플 코드: 주요 메서드 사용 예시
```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(0);

        // 현재 값 조회
        System.out.println("초기값: " + atomicInteger.get());

        // 값 설정
        atomicInteger.set(100);
        System.out.println("set 후: " + atomicInteger.get());

        // 1 증가 후 결과 반환
        int afterIncrement = atomicInteger.incrementAndGet();
        System.out.println("incrementAndGet: " + afterIncrement);

        // 1 증가 후 이전 값 반환
        int beforeIncrement = atomicInteger.getAndIncrement();
        System.out.println("getAndIncrement (이전 값): " + beforeIncrement);
        System.out.println("현재 값: " + atomicInteger.get());

        // 5 증가 후 결과 반환
        int afterAdd = atomicInteger.addAndGet(5);
        System.out.println("addAndGet(5): " + afterAdd);

        // 5 증가 후 이전 값 반환
        int beforeAdd = atomicInteger.getAndAdd(5);
        System.out.println("getAndAdd(5) (이전 값): " + beforeAdd);
        System.out.println("현재 값: " + atomicInteger.get());

        // CAS 연산
        boolean updated = atomicInteger.compareAndSet(115, 200);
        System.out.println("compareAndSet(115 → 200): " + updated);
        System.out.println("최종 값: " + atomicInteger.get());
    }
}
```

## ✅ 핵심 요약
- AtomicInteger는 락 없이도 원자적 연산을 제공하는 고성능 클래스입니다.
- incrementAndGet(), getAndAdd() 등은 멀티스레드 환경에서도 안전하게 값 변경 가능
- compareAndSet()은 CAS(Compare-And-Swap) 기반으로 조건부 업데이트를 수행

---
