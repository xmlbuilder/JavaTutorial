# 인터럽트 4 (`Thread.interrupted()`)
이번 흐름은 인터럽트 상태를 직접 확인하고 초기화하는 방식을 통해 자원 정리를 안정적으로 수행하는 구조를 보여주는 아주 중요한 예제.  
아래에 핵심 내용을 정리.

## 소스 코드
```java
public class ThreadStopMainV4 {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task, "work");
        thread.start();
        sleep(100); //시간을 줄임
        log("작업 중단 지시 - thread.interrupt()");
        thread.interrupt();
        log("work 스레드 인터럽트 상태1 = " + thread.isInterrupted());
    }
    
    static class MyTask implements Runnable {
        @Override
        public void run() {
            while (!Thread.interrupted()) { //인터럽트 상태 변경O
                log("작업 중");
            }
            log("work 스레드 인터럽트 상태2 = " +
            Thread.currentThread().isInterrupted());
            try {
                log("자원 정리 시도");
                Thread.sleep(1000);
                log("자원 정리 완료");
            } catch (InterruptedException e) {
                log("자원 정리 실패 - 자원 정리 중 인터럽트 발생");
                log("work 스레드 인터럽트 상태3 = " +
                Thread.currentThread().isInterrupted());
            }
            log("작업 종료");
        }
    }
}
```

## ✅ 핵심 개념 요약: Thread.interrupted()의 의미

| 메서드                  | 설명                                                                 |
|-------------------------|----------------------------------------------------------------------|
| `isInterrupted()`         | 현재 스레드의 인터럽트 상태를 **확인만** 함. 상태는 그대로 유지됨.     |
| `Thread.interrupted()`   | 현재 스레드의 인터럽트 상태를 **확인하고 동시에 초기화함**. 상태가 false로 바뀜. |


## 🧠 실행 흐름 요약
- main 스레드가 work 스레드에 interrupt() 호출 → work 스레드는 인터럽트 상태가 됨 (true)
- work 스레드는 while (!Thread.interrupted()) 조건에서 인터럽트 상태를 확인하고 초기화
- 반복문을 탈출하면서 인터럽트 상태는 이미 false로 복구됨
- 이후 자원 정리 단계에서 Thread.sleep()을 호출해도 예외 없이 정상 실행
- 자원 정리 완료 후 작업 종료

## 🧪 왜 이 방식이 안전한가?

| 항목                     | 설명                                                                 | 결과 또는 영향                         |
|--------------------------|----------------------------------------------------------------------|----------------------------------------|
| 인터럽트 상태 초기화      | `Thread.interrupted()`가 상태를 확인하면서 동시에 false로 초기화함     | 이후 코드에서 인터럽트 예외 발생 안 함 |
| 인터럽트 상태 = false     | 자원 정리 시점에 상태가 false이므로 `sleep()` 호출 시 예외 없음         | 자원 정리 정상 수행                    |
| sleep() 호출              | 인터럽트 상태가 false이므로 `InterruptedException` 발생하지 않음        | 안정적인 흐름 유지                     |
| InterruptedException 없음 | 자원 정리 중 예외 없이 흐름이 이어짐                                  | 자원 정리 완료 후 정상 종료            |

## 🧩 개선 포인트와 선택 기준

| 상황 또는 목적                         | isInterrupted() 사용                          | Thread.interrupted() 사용                        |
|----------------------------------------|-----------------------------------------------|--------------------------------------------------|
| 반복문 탈출 조건 확인                  | ✅ 상태만 확인하고 유지할 때 적합              | ✅ 상태 확인과 동시에 초기화가 필요할 때 적합     |
| 이후 코드에서 인터럽트 예외 발생 방지  | ❌ 상태가 유지되어 예외 발생 가능              | ✅ 상태 초기화로 예외 없이 자원 정리 가능         |
| 인터럽트 상태를 유지해야 하는 경우     | ✅ 상태를 유지하며 외부에서 재확인 가능         | ❌ 상태가 초기화되므로 이후 확인 불가             |
| 자원 정리 등 민감한 코드 실행 전       | ❌ 상태 유지로 예외 발생 위험 있음             | ✅ 상태 초기화로 안전하게 실행 가능               |


## 🔚 결론
Thread.interrupted()는 반복문 탈출과 동시에 인터럽트 상태를 초기화해주기 때문에,  
자원 정리나 후속 작업에서 예외 없이 안정적으로 흐름을 이어갈 수 있는 구조를 만들어줍니다.  
반면 isInterrupted()는 상태를 유지하므로, 이후 코드에서 예외 발생 가능성이 있으니 주의가 필요합니다.  

---


