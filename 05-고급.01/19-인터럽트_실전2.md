# 인터럽트 실전 2
이 예제는 `interrupt()` 와 `work`  플래그를 동시에 활용하여 스레드를 즉시 종료하는 구조를 보여주는 예.  
아래에 코드 흐름을 단계별로 설명하고, 반응성 향상 포인트를 함께 정리.

##  소스 코드
```java
public class MyPrinterV2 {
    public static void main(String[] args) throws InterruptedException {
        Printer printer = new Printer();
        Thread printerThread = new Thread(printer, "printer");
        printerThread.start();
        Scanner userInput = new Scanner(System.in);
        while (true) {
            System.out.println("프린터할 문서를 입력하세요. 종료 (q): ");
            String input = userInput.nextLine();
            if (input.equals("q")) {
                printer.work = false;
                printerThread.interrupt();
                break;
            }
            printer.addJob(input);
        }
    }
    static class Printer implements Runnable {
        volatile boolean work = true;
        Queue<String> jobQueue = new ConcurrentLinkedQueue<>();
        
        @Override
        public void run() {
            while (work) {
                if (jobQueue.isEmpty()) {
                    continue;
                }
                try {
                    String job = jobQueue.poll();
                    log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
                    Thread.sleep(3000); //출력에 걸리는 시간
                    log("출력 완료: " + job);
                } catch (InterruptedException e) {
                    log("인터럽트!");
                    break;
                }
            }
            log("프린터 종료");
        }

        public void addJob(String input) {
            jobQueue.offer(input);
        }
    }
}
```

## 🧩 MyPrinterV2 구조 요약
- main 스레드: 사용자 입력을 받아 프린터에 전달
- printer 스레드: 입력된 작업을 출력하고, 종료 지시를 감지하면 즉시 종료
- 핵심 개선점: interrupt() + work=false 병행 사용으로 즉시 반응 가능

## 🔄 단계별 코드 흐름 설명
### 1️⃣ Printer 인스턴스 생성 및 스레드 시작
```java
Printer printer = new Printer();
Thread printerThread = new Thread(printer, "printer");
printerThread.start();
```

- Printer 객체 생성
- printerThread 시작 → run() 메서드 실행

### 2️⃣ 사용자 입력 처리 (main 스레드)
```java
Scanner userInput = new Scanner(System.in);
while (true) {
    System.out.println("프린터할 문서를 입력하세요. 종료 (q): ");
    String input = userInput.nextLine();
```

- 사용자 입력을 반복적으로 받음
- "q" 입력 시 종료 지시

###  3️⃣ 종료 지시 처리
```java
if (input.equals("q")) {
    printer.work = false;
    printerThread.interrupt();
    break;
}
```

- work=false: while(work) 조건을 다음 루프에서 탈출
- interrupt(): sleep() 상태인 스레드를 즉시 깨움
- 두 가지를 병행하여 모든 상태에서 즉시 종료 가능

### 4️⃣ 작업 추가
```java
printer.addJob(input);
```

- 입력된 문자열을 jobQueue에 추가
- ConcurrentLinkedQueue 사용으로 스레드 안전성 확보

### 5️⃣ 프린터 스레드의 작업 처리
```java
while (work) {
    if (jobQueue.isEmpty()) {
        continue;
    }
    try {
        String job = jobQueue.poll();
        log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
        Thread.sleep(3000); // 출력 시간
        log("출력 완료: " + job);
    } catch (InterruptedException e) {
        log("인터럽트!");
        break;
    }
}
log("프린터 종료");
```

- jobQueue가 비어 있으면 continue로 대기
- 작업이 있으면 출력 시작 → sleep(3000)
- interrupt() 발생 시 InterruptedException으로 즉시 탈출
- work=false일 경우 다음 루프에서 while 탈출


## ✅ 실행 흐름 시각화 (요약)
사용자 입력 → jobQueue 추가 → printer 스레드가 출력
입력 "q" → work=false + interrupt() → 즉시 종료


## ⚡ 반응성 향상 포인트

| 메커니즘               | 적용 위치           | 역할 또는 효과                                 | 반응성 향상 이유                          |
|------------------------|---------------------|------------------------------------------------|-------------------------------------------|
| interrupt()            | sleep() 중          | 대기 중인 스레드를 즉시 깨움                   | `sleep()` 상태에서도 즉시 종료 가능        |
| work = false           | while(work) 조건문  | 반복문 탈출 조건으로 사용                      | 루프 조건에서 빠르게 종료 가능             |
| ConcurrentLinkedQueue  | jobQueue 처리       | 스레드 안전한 작업 큐                         | 다중 스레드 환경에서도 안정적 작업 처리     |


## 🔍 요약 포인트
- interrupt()는 대기 중인 스레드를 깨우는 직접적인 수단으로, 즉시 반응을 가능하게 함
- work=false는 루프 조건을 제어하여 스레드가 다음 반복에서 빠져나갈 수 있게 함
- ConcurrentLinkedQueue는 스레드 간 안전한 데이터 공유를 보장하여 작업 처리의 안정성을 높임

---





