# 생산자 소비자 문제 분석
아래는 생산자 먼저 실행되는 예제1 흐름을 기반으로 한 다이어그램과 함께,  
그 원리를 자세히 설명한 내용입니다.

## 🧵 생산자 소비자 문제 - 예제1 흐름 요약

```mermaid
flowchart TD
    Start([START])
    PStart([Producer starts first])
    QFull{Is queue full?}
    PutData([put → data1, data2])
    QueueState[[Queue: [data1, data2]]]
    CStart([Consumer starts next])
    QEmpty{Is queue empty?}
    TakeData([take → data1, data2])
    Sync([synchronized])
    EndAll([All threads TERMINATED])
    End([END])

    DiscardP3([Producer3 discards data3])
    DiscardC3([Consumer3 gets null])

    Start --> PStart --> QFull
    QFull -- No --> PutData --> QueueState --> CStart --> QEmpty
    QFull -- Yes --> DiscardP3
    QEmpty -- No --> TakeData --> Sync --> EndAll --> End
    QEmpty -- Yes --> DiscardC3 --> EndAll
```

## 🔍 다이어그램 설명
- Producer starts first: 생산자 스레드가 먼저 실행됨
- Is queue full?: 큐가 가득 찼는지 확인
- No: data1, data2 저장
- Yes: data3는 버림
- Consumer starts next: 소비자 스레드가 실행됨
- Is queue empty?: 큐가 비어 있는지 확인
- No: data1, data2 소비
- Yes: null 반환
- 모든 연산은 synchronized 임계 영역에서 수행됨
- 모든 스레드 종료 후 END


## 🔐 락과 임계 영역
- 모든 put()과 take() 연산은 synchronized로 보호된 임계 영역에서 수행됩니다.
- 스레드는 **락(lock)** 을 획득해야만 큐에 접근할 수 있습니다.


## 🧪 실행 흐름 상세 분석  
### 1️⃣ 생산자 실행

| 단계 | 생산 데이터 | 큐 상태 변화         |
|------|--------------|----------------------|
| p1   | data1        | [data1]              |
| p2   | data2        | [data1, data2]       |
| p3   | data3        | [data1, data2] (버림) |

- p3는 큐가 가득 찼기 때문에 데이터를 버립니다.
- 이 문제는 버퍼 크기 제한으로 인해 발생합니다.

### 2️⃣ 소비자 실행

| 단계 | 소비 데이터 | 큐 상태 변화         |
|------|--------------|----------------------|
| c1   | data1        | [data2]              |
| c2   | data2        | []                   |
| c3   | null         | []                   |

- c3는 큐에 데이터가 없기 때문에 null을 반환받습니다.
- 이 역시 버퍼 비어 있음 문제입니다.

## 🧠 개선 아이디어
### ❌ 현재 방식의 한계
- 생산자는 큐가 가득 차면 데이터를 버림
- 소비자는 큐가 비어 있으면 null 반환
- 데이터 손실과 불필요한 소비 시도 발생

### ✅ 개선 방향 (예제2에서 적용 예정)
- 생산자는 큐가 가득 차면 대기(wait)
- 소비자는 큐가 비어 있으면 대기(wait)
- 큐에 변화가 생기면 notify()로 깨움

## 💡 예제 코드 개선 방향 (예고)
```java
@Override
public synchronized void put(String data) {
    while (queue.size() == max) {
        wait(); // 큐가 가득 차면 대기
    }
    queue.offer(data);
    notifyAll(); // 소비자 깨움
}
```
```java
@Override
public synchronized String take() {
    while (queue.isEmpty()) {
        wait(); // 큐가 비어 있으면 대기
    }
    String data = queue.poll();
    notifyAll(); // 생산자 깨움
    return data;
}
```
- 이 방식은 BoundedQueueV2에서 적용될 예정이며, 데이터 손실 없이 안정적인 생산/소비 흐름을 구현할 수 있습니다.
