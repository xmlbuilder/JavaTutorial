# 인터럽트 실전 3
이번 프린터 예제 V3는 인터럽트 상태를 직접 확인하는 방식으로 코드를 더 간결하고 반응성 있게 개선한 사례.  
아래에 핵심 개선 사항과 흐름을 단계별로 정리.

## 소스 코드
```java
public class MyPrinterV3 {
    public static void main(String[] args) throws InterruptedException {

        Printer printer = new Printer();
        Thread printerThread = new Thread(printer, "printer");
        printerThread.start();
        Scanner userInput = new Scanner(System.in);

        while (true) {
            System.out.println("프린터할 문서를 입력하세요. 종료 (q): ");
            String input = userInput.nextLine();
            if (input.equals("q")) {
                printerThread.interrupt();
                break;
            }
            printer.addJob(input);
        }
    }

    static class Printer implements Runnable {
        Queue<String> jobQueue = new ConcurrentLinkedQueue<>();
        
        @Override
        public void run() {
            while (!Thread.interrupted()) {
                if (jobQueue.isEmpty()) {
                    continue;
                }
                try {
                    String job = jobQueue.poll();
                    log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
                    Thread.sleep(3000); //출력에 걸리는 시간
                    log("출력 완료: " + job);
                } catch (InterruptedException e) {
                    log("인터럽트!");
                    break;
                }
            }
            log("프린터 종료");
        }
        public void addJob(String input) {
            jobQueue.offer(input);
        }
    }
}
```

## ✅ 개선 핵심 요약

| 항목                   | 설명 또는 적용 위치                      | 개선 효과 및 이유                          |
|------------------------|------------------------------------------|--------------------------------------------|
| `work`                   | 제거됨                                   | 상태 변수 없이 인터럽트로 흐름 제어 가능     |
| `Thread.interrupted()`   | printer 스레드의 while 조건에서 사용     | 반복문 탈출 + 인터럽트 상태 초기화           |
| `interrupt()`            | main 스레드에서 printerThread.interrupt() 호출 | sleep 중에도 즉시 반응 가능                  |


## 🔄 코드 흐름 단계별 설명
### 1️⃣ 프린터 스레드 시작
```java
Printer printer = new Printer();
Thread printerThread = new Thread(printer, "printer");
printerThread.start();
```

- Printer 객체를 생성하고 스레드로 실행

### 2️⃣ 사용자 입력 처리 (main 스레드)
```java
while (true) {
    System.out.println("프린터할 문서를 입력하세요. 종료 (q): ");
    String input = userInput.nextLine();
    if (input.equals("q")) {
        printerThread.interrupt(); // 종료 지시
        break;
    }
    printer.addJob(input); // 작업 추가
}
```

- "q" 입력 시 interrupt() 호출로 프린터 스레드 종료 유도
- work 변수 없이도 종료 흐름 제어 가능

### 3️⃣ 프린터 스레드 작업 처리
```java
while (!Thread.interrupted()) {
    if (jobQueue.isEmpty()) {
        continue;
    }
    try {
        String job = jobQueue.poll();
        log("출력 시작: " + job + ", 대기 문서: " + jobQueue);
        Thread.sleep(3000);
        log("출력 완료: " + job);
    } catch (InterruptedException e) {
        log("인터럽트!");
        break;
    }
}
log("프린터 종료");
```

- Thread.interrupted()로 반복 조건 제어
- sleep() 중 인터럽트 발생 시 InterruptedException으로 즉시 탈출
- 반복문과 예외 처리 모두 인터럽트에 반응 → 이중 안전 장치


## 🧠 실행 흐름 요약
사용자 입력 → jobQueue 추가 → 프린터 스레드가 출력  
입력 "q" → interrupt() 호출 → 반복문 탈출 또는 예외 발생 → 프린터 종료  

## ⚡ 반응성 향상 요인

| 메커니즘               | 적용 위치 또는 조건       | 반응성 향상 이유                                 |
|------------------------|---------------------------|--------------------------------------------------|
| `Thread.interrupted()`   | while 반복 조건           | 인터럽트 상태 확인과 동시에 초기화 → 루프 즉시 탈출 가능 |
| `InterruptedException`   | Thread.sleep() 중         | 대기 중 인터럽트 발생 시 즉시 예외 처리 → 빠른 종료 가능 |
| `interrupt()`            | main 스레드에서 호출      | 어떤 상태든 스레드에 인터럽트 신호 전달 → 즉시 반응 유도 |

## 🔍 핵심 요약
- Thread.interrupted()는 반복문에서 인터럽트 상태를 확인하고 초기화까지 수행하므로 이후 코드에 영향 없음
- InterruptedException은 sleep() 중 인터럽트 발생 시 즉시 예외 처리로 흐름을 종료할 수 있음
- interrupt()는 스레드가 대기 중이든 실행 중이든 즉시 반응하도록 만드는 핵심 트리거


## ✅ 결론
이 구조는 불필요한 상태 변수 없이, 인터럽트만으로 스레드 종료를 제어할 수 있어  
코드가 간결해지고 반응성도 향상됩니다.  
`Thread.interrupted()`는 반복문 제어와 상태 초기화를 동시에 처리할 수 있는 강력한 도구입니다.  

----


