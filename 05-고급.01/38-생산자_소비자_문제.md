# 🧵 생산자 소비자 문제란?
멀티스레드 환경에서 **데이터를 생산하는 스레드(Producer)** 와  
**소비하는 스레드(Consumer)** 가 **공유 버퍼(Buffer)** 를 통해 데이터를 주고받을 때 발생하는 동시성 문제입니다.

## 📌 핵심 구성 요소

| 역할 또는 개념     | 설명 또는 관련 메서드           |
|--------------------|----------------------------------|
| 생산자 (Producer)  | `put()` 메서드를 통해 데이터 생산 |
| 소비자 (Consumer)  | `take()` 메서드를 통해 데이터 소비 |
| 버퍼 (Buffer)      | `Bounded` 크기의 공유 저장 공간   |

## ⚠️ 문제 상황
- 버퍼가 가득 찬 경우: 생산자는 대기해야 함
- 버퍼가 비어 있는 경우: 소비자는 대기해야 함

## 🎨 비유로 이해하기
### 🍽️ 레스토랑 비유
- 생산자: 요리사
- 소비자: 손님
- 버퍼: 서빙 카운터

### 🧃 음료 공장 비유
- 생산자: 음료 공장
- 소비자: 상점
- 버퍼: 창고

## 🧪 예제 코드 구성
### 1️⃣ 인터페이스 정의
```java
public interface BoundedQueue {
    void put(String data);
    String take();
}
```
- put(): 생산자가 호출
- take(): 소비자가 호출

### 2️⃣ 버퍼 구현체: BoundedQueueV1
```java
private final Queue<String> queue = new ArrayDeque<>();
private final int max;
```
- synchronized로 임계 영역 보호
- 큐가 가득 차면 put()은 데이터를 버림
- 큐가 비어 있으면 take()는 null 반환

### 3️⃣ 생산자 스레드: ProducerTask
```java
queue.put(request);
```
- 데이터를 생성하여 큐에 넣음
- 로그로 생산 시도 및 완료 출력

### 4️⃣ 소비자 스레드: ConsumerTask
```java
String data = queue.take();
```

- 큐에서 데이터를 꺼내 소비
- 로그로 소비 시도 및 완료 출력

### 5️⃣ 실행 코드: BoundedMain
- 큐 생성: BoundedQueueV1(2)
- 실행 순서 선택:
- producerFirst(queue)
- consumerFirst(queue)
- 스레드 상태 출력: Thread.getState()

## 🔐 동기화와 임계 영역
- queue는 공유 자원이므로 synchronized로 보호
- put()과 take()는 동시에 실행되면 안 됨
- 예외 상황 방지: queue.size() 확인 후 offer() 하기 전에 다른 스레드가 개입할 수 있음

## ✅ 핵심 요약

| 항목               | 설명 또는 관련 기능                                      |
|--------------------|----------------------------------------------------------|
| 동기화 처리         | `synchronized` 키워드로 임계 영역 보호                   |
| 공유 자원 보호      | `queue`에 대한 접근을 동기화하여 데이터 충돌 방지         |
| 스레드 상태 추적    | `Thread.getState()`로 `RUNNABLE`, `WAITING` 상태 확인 가능 |


# 단계적 진행 사항

아래는 생산자 소비자 문제의 첫 번째 예제(BoundedQueueV1)를 중심으로,  
실행 흐름과 코드 구조를 단계적으로 정리한 요약입니다.

## BoundedQueue 소스
```java
public class BoundedQueueV1 implements BoundedQueue {

    private final Queue<String> queue = new ArrayDeque<>();
    private final int max;
    public BoundedQueueV1(int max) {
        this.max = max;
    }

    @Override
    public synchronized void put(String data) {
        if (queue.size() == max) {
        log("[put] 큐가 가득 참, 버림: " + data);
        return;
        }
        queue.offer(data);
    }

    @Override
    public synchronized String take() {
        if (queue.isEmpty()) {
            return null;
        }
        return queue.poll();
    }

    @Override
    public String toString() {
        return queue.toString();
    }
}
```

## 📦 1. BoundedQueue 선택
```java
BoundedQueue queue = new BoundedQueueV1(2);
```
- BoundedQueue는 버퍼 역할을 하는 인터페이스
- BoundedQueueV1은 가장 기본적인 구현체
- 버퍼 크기: 2 → 최대 2개의 데이터만 저장 가능
- 초과 시 생산자는 데이터를 버림
- 비어 있을 경우 소비자는 null 반환

## ⚙️ 2. 실행 순서 선택
```java
producerFirst(queue); // 생산자 먼저 실행
//consumerFirst(queue); // 소비자 먼저 실행
```
- 두 방식 중 하나만 선택해야 함
- 동시에 실행하면 예상치 못한 오류 발생 가능
- 목적: 실행 순서에 따른 동작 차이를 관찰하기 위함

## 🔍 3. producerFirst() 코드 분석
```java
private static void producerFirst(BoundedQueue queue) {
    log("== [생산자 먼저 실행] 시작 ==");
    List<Thread> threads = new ArrayList<>();
    startProducer(queue, threads);     // 생산자 3명 실행
    printAllState(queue, threads);     // 상태 출력
    startConsumer(queue, threads);     // 소비자 3명 실행
    printAllState(queue, threads);     // 상태 출력
    log("== [생산자 먼저 실행] 종료 ==");
}
```
- startProducer(): 3개의 생산자 스레드 실행 (data1, data2, data3)
- startConsumer(): 3개의 소비자 스레드 실행
- sleep(100)을 통해 순차적 실행 유도
- printAllState(): 각 스레드의 상태 출력 (RUNNABLE, TERMINATED 등)

## 🧵 실행 흐름 요약 (생산자 먼저)

| 단계 | 스레드       | 동작 또는 데이터 처리 결과         |
|------|--------------|------------------------------------|
| 1    | producer1    | 생산 → `data1` 큐에 저장            |
| 2    | producer2    | 생산 → `data2` 큐에 저장            |
| 3    | producer3    | 큐 가득 참 → `data3` 버림           |
| 4    | consumer1    | 소비 → `data1` 꺼냄                 |
| 5    | consumer2    | 소비 → `data2` 꺼냄                 |
| 6    | consumer3    | 큐 비어 있음 → `null` 반환          |


## 📋 실행 결과 요약
- 큐 상태 변화: [] → [data1] → [data1, data2] → [data1, data2] → [data2] → [] → []
- 스레드 상태: producer1~3 → TERMINATED / consumer1~3 → TERMINATED
    - 생산자 3명 중 2명만 성공적으로 생산
    - 소비자 3명 중 2명만 성공적으로 소비
    - 마지막 소비자는 null을 소비함

## ✅ 핵심 요약
| 항목               | 설명 또는 관련 동작                                 |
|--------------------|-----------------------------------------------------|
| 동기화 처리         | `synchronized`로 `put()` / `take()` 임계 영역 보호   |
| 스레드 상태 추적    | `Thread.getState()`로 `RUNNABLE`, `TERMINATED` 확인 |
| 소비 실패 처리      | 큐가 비어 있으면 `null` 반환                        |

---

## 🧵 소비자 먼저 실행 흐름 요약
###  1️⃣ 실행 설정
```java
BoundedQueue queue = new BoundedQueueV1(2);
//producerFirst(queue); // ❌ 주석 처리
consumerFirst(queue);   // ✅ 소비자 먼저 실행
```
- 버퍼 크기: 2
- 소비자 스레드 3개 → 먼저 실행
- 생산자 스레드 3개 → 나중에 실행

### 2️⃣ 실행 흐름 (소비자 먼저 실행)

| 단계 | 스레드       | 동작 또는 데이터 처리 결과         |
|------|--------------|------------------------------------|
| 1    | consumer1    | 소비 → `null` (큐 비어 있음)        |
| 2    | consumer2    | 소비 → `null` (큐 비어 있음)        |
| 3    | consumer3    | 소비 → `null` (큐 비어 있음)        |
| 4    | producer1    | 생산 → `data1` 큐에 저장            |
| 5    | producer2    | 생산 → `data2` 큐에 저장            |
| 6    | producer3    | 큐 가득 참 → `data3` 버림           |

### 3️⃣ 큐 상태 변화
초기 상태: []  
    → [data1]  
    → [data1, data2]  
    → [data1, data2] (data3는 버려짐)  

### 4️⃣ 스레드 상태 요약

| 스레드 이름     | 상태         |
|----------------|--------------|
| consumer1      | TERMINATED   |
| consumer2      | TERMINATED   |
| consumer3      | TERMINATED   |
| producer1      | TERMINATED   |
| producer2      | TERMINATED   |
| producer3      | TERMINATED   |

### ✅ 핵심 요약

| 항목               | 설명 또는 관련 동작                                 |
|--------------------|-----------------------------------------------------|
| 소비 실패 처리      | 큐가 비어 있으면 소비자는 `null` 반환                |
| 생산 시도 데이터    | 생산자는 `data1`, `data2`, `data3`를 생산             |
| 최종 큐 상태        | `[data1, data2]` → `data3`는 버퍼 초과로 버려짐       |
| 동기화 처리         | `synchronized`로 `put()` / `take()` 임계 영역 보호   |
| 소비자 반환값       | 초기 소비자들은 모두 `null` 소비                      |
| 스레드 상태 추적    | `Thread.getState()`로 `TERMINATED` 확인 가능         |

- 이 예제를 통해 버퍼가 비어 있을 때 소비자가 먼저 실행되면 데이터를 소비하지 못하고 종료된다는 점을 확인할 수 있습니다

---
