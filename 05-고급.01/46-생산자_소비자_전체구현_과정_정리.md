# 구현 흐름 정리
아래는 자바의 스레드 대기 구조와 BoundedQueue 구현 흐름을 중심으로 정리한 내용입니다.  
핵심 개념, 대기 구조, 각 버전의 특징, 그리고 실무적 의미까지 깔끔하게 요약.

## 🔒 자바의 스레드 대기 구조

### ✅ synchronized 기반
| 상태     | 진입 조건        | 대기 장소             | 설명                                 |
|----------|------------------|------------------------|--------------------------------------|
| BLOCKED  | synchronized 진입 | 락 대기 집합           | 락을 얻지 못한 경우, 모니터 락을 기다림 |
| WAITING  | wait() 호출       | 스레드 대기 집합       | 락을 가진 상태에서 wait() 호출 → 락 반납 후 조건 대기 |

### 🧠 핵심 요약
- BLOCKED: 락을 얻지 못한 스레드가 synchronized 진입을 시도할 때 발생
- WAITING: 락을 가진 스레드가 wait() 호출 후 조건 대기 집합으로 이동할 때 발생
- 두 상태는 서로 다른 대기 장소에서 관리되며, 다른 이유로 대기하는 상태입니다
- notify() 호출 시 WAITING 스레드가 깨어나지만, 락을 얻지 못하면 다시 BLOCKED 상태로 진입

### ✅ ReentrantLock 기반

| 상태     | 진입 조건        | 대기 장소                  | 설명                                 |
|----------|------------------|-----------------------------|--------------------------------------|
| WAITING  | lock() 호출       | ReentrantLock 대기 큐         | 락을 얻지 못한 경우, 락 대기 큐에서 대기 |
| WAITING  | await() 호출      | Condition 객체의 대기 공간     | 락을 가진 상태에서 await() 호출 → 락 반납 후 조건 대기 |

### 🧠 핵심 요약
- ReentrantLock.lock() 호출 시 락이 없으면 WAITING 상태로 락 대기 큐에서 대기
- condition.await() 호출 시 락을 반납하고 Condition 객체의 대기 공간에서 WAITING 상태로 대기
- signal()로 깨운 스레드는 다시 락을 얻기 위해 ReentrantLock 대기 큐로 이동 → 락을 얻어야만 RUNNABLE 상태로 전환
- signal() 호출 시 await() 중인 스레드가 깨어나지만, 락을 얻지 못하면 다시 WAITING 상태로 락 대기 큐에서 대기

## 🧵 2단계 대기소 개념
- 1차 대기소: 락을 얻기 위한 대기 공간 (BLOCKED 또는 ReentrantLock 대기 큐)
- 2차 대기소: 조건을 기다리는 대기 공간 (WAITING 상태, wait() 또는 await())
    - 깨어난 스레드는 바로 실행되지 않으며, 락을 다시 획득해야만 RUNNABLE 상태로 전환되어 임계 영역을 수행할 수 있음

## 📦 BoundedQueue 구현 흐름 요약

| 버전           | 동기화 방식       | 스레드 제어 방식             |
|----------------|------------------|------------------------------|
| V1             | 없음              | 없음 (데이터 손실 발생 가능)   |
| V2             | synchronized      | 반복문 대기 (비효율적, 락 점유) |
| V3             | synchronized      | wait() / notify() 사용       |
| V4             | ReentrantLock     | signal() 사용, 대기 공간 하나 |
| V5             | ReentrantLock     | Condition 분리 (producer/consumer) |

## 🧠 핵심 요약
- V1: 단순 큐. 스레드 제어 불가 → 생산자/소비자 충돌 발생
- V2: synchronized + 반복문 → 락을 들고 대기 → 전체 BLOCKED 위험
- V3: wait() / notify() → 락 반납 후 대기 가능하지만, 대기 공간이 하나
- V4: ReentrantLock으로 전환 → 구조는 같지만 여전히 대기 공간 하나
- V5: Condition을 분리하여 정확한 상대방만 깨움 → 효율적이고 깔끔한 동기화


## 🧠 실무적 의미
- BoundedQueueV5는 단순한 큐를 넘어서 스레드 제어까지 포함된 고급 자료 구조
- 생산자 소비자 문제를 직접 구현하면서:
- BLOCKED, WAITING, RUNNABLE 상태의 의미
- synchronized의 한계와 ReentrantLock의 필요성
- Condition을 통한 대기 공간 분리의 효과
- 이런 과정을 통해 멀티스레드의 기본기와 동기화 메커니즘을 깊이 이해하게 됨

## 🧩 BlockingQueue와의 연결
- 자바는 이미 java.util.concurrent.BlockingQueue 인터페이스를 통해 생산자 소비자 문제를 해결할 수 있는 구현체를 제공
- 하지만 직접 구현해보는 과정은 멀티스레드의 핵심 원리를 체득하는 데 매우 중요
- 우리가 만든 BoundedQueueV5는 실무에서도 충분히 활용 가능한 수준이며, BlockingQueue의 동작 원리를 직접 구현한 것과 동일

## ✅ 결론
- 생산자 소비자 문제는 멀티스레드 학습의 교과서
- synchronized → ReentrantLock → Condition으로 이어지는 진화 과정은 자바 동기화의 핵심 흐름
- BoundedQueueV5는 효율적이고 안전한 스레드 제어 큐로, 실무에서도 재사용 가능
- 이 과정을 통해 멀티스레드의 구조, 상태 전환, 대기소 개념을 명확히 이해하게 됨

---




